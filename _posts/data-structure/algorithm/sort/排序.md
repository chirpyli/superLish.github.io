排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。这里介绍的几种排序算法都是内部排序。代码实现见[sort.cpp](./sort.cpp)

---
### 冒泡排序法
在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。时间复杂度`O(n^2)`。

### 双向冒泡法
通常的冒泡都是单向的，而这里是双向的，也就是说，还要进行反向冒泡。时间复杂度`O(n^2)`。

### 交换排序法
每次用当前的元素一一的同其后的元素比较并交换，时间复杂度`O(n^2)`。

### 选择排序法
要点：从数据中选择最小的同第一个值交换，再从剩下的部分中选择最小的与第二个交换，反复下去。由于每次外层循环只产生一次交换，所以在数据较乱的时候，可以减少一定的交换次数（与冒泡法和交换法相比较）。

### 插入排序法
插入法较为复杂，它的基本工作原理是抽出牌，在前面的牌中找到相应的位置插入，然后继续下一张。中间有个过程挺像冒泡的，注意下面代码的while终止条件。

### 快速排序法
思路：
1.首先我们选择一个中间middle，程序中我们使用数组中间值。
2.然后比对比它小的放在左边，比它大的放在右边（具体实现是从两边找，找到后交换）。
3.然后对两边分别使用这个过程（最容易的方法，递归）。

### 归并排序
思路： 与快速排序思路近似，先将序列分割，分割后排序，排序后归并。可用递归实现序列分割的过程，并且是最小单元先排序，然后逐渐合并。

### 桶排序
思路： 以空间换时间, 可以时间复杂度降到`O(n)`，但却增大了空间复杂度，占用空间的多少取决于待排序数组中的做大元素值是多少。而且待排序的元素不能有重复的元素，只能是无符号整形，浮点数是没法用这种办法的。