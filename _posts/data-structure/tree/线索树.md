### 线索树
在二叉查找树中，深度优先遍历的实现有递归和非递归两种方法，非递归使用了栈，递归方式本质上也是栈的形式，当树非常大且树不平衡时，最坏的情况是栈存储了整颗树，这是非常不好的情况。有没有不用栈的方式实现深度优先遍历呢？线索树是其中的一种方法。遍历本质上是将非线性结构转为线性结构，这里可以认为遍历的过程是类似于一个链表的访问过程，每个节点都有前驱和后继（特殊节点除外）。如果二叉查找树节点中存储一个前驱和后继，这个问题就解决了。但是如果新增两个指针指向前驱和后继空间代价较大，可以利用二叉查找树中空闲的指针域外加一个标识位来表明这是一个右子节点指针还是一个后继节点指针。

具体实现时，在插入节点时需要多计算一个后继，虽增加了插入操作的开销但降低了遍历过程中的空间复杂度（对空间资源这块有增有减，减的是遍历过程中无需用栈，增的是标识位）。

线索树代码实现[threadtree.h](./threadtree.h)


