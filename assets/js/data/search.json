[ { "title": "关于是否升级第三方库的思考", "url": "/superLish.github.io/posts/%E5%85%B3%E4%BA%8E%E6%98%AF%E5%90%A6%E5%8D%87%E7%BA%A7%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E6%80%9D%E8%80%83/", "categories": "CS, 软件工程", "tags": "软件工程", "date": "2021-04-07 00:00:00 +0800", "snippet": "关于是否升级第三方库的思考在开发中，我们经常需要很多依赖库或者使用很多第三方库，这里就有个问题了，我们什么时候需要升级依赖库或者是第三方库呢？之所以有这个问题，是因为，如果升级不当可能会对现有程序产生影响，造成目前的程序产生未知的问题。对未知影响最大是稳定性，系统稳定性在很多时候是非常非常重要的，对这个问题，有如下原则思考： 到了不得不升级的时候再升级，比如现有库功能无法满足要求，升级后的新版本可以满足功能要求。如果已有版本的功能已经满足现有要求，新版本增加的功能并不是现有需要的，则不升级。 新版本修复了已知Bug，这个没什么好说的，都有Bug了，不升版本问题解决不了。 新版本关键..." }, { "title": "为什么要构建自己的博客", "url": "/superLish.github.io/posts/why-build-my-own-blog/", "categories": "Blogging, Diary", "tags": "diary", "date": "2021-02-08 20:55:00 +0800", "snippet": "为什么要构建自己的博客之前一直在CSDN上写博客，也写了好久，但是CSDN的问题就是商业化气息太浓重了，个人比较喜欢简洁一些的风格。也在微信公众号上写了若干，但总觉得维护起来比较麻烦，尤其是想修改原文的时候。恰逢农历年因疫情原因不能回家，就有了一个构建自己的博客的想法，且趁这段时间将以前的博文梳理迁移过来,。我对自己博客的想法就是，简洁，便于维护，方便归档查询。最终决定采用Github+Jekyll构建自己的博客，在theme中选取了自己喜欢的Chirpy。按照Chaipy-REAMDE文档的说明以及参考Working with GitHub Pages一步步构建出来。Ready, Go!" }, { "title": "Rust异步之自己构造block_on", "url": "/superLish.github.io/posts/Rust%E5%BC%82%E6%AD%A5%E4%B9%8B%E8%87%AA%E5%B7%B1%E6%9E%84%E9%80%A0block_on/", "categories": "CS, Rust", "tags": "Rust, async", "date": "2021-02-05 20:55:00 +0800", "snippet": "一个block_on代码示例我们在进行异步编程时，经常会有下面形式的代码：use tokio::time::Duration;fn main() { let runtime = tokio::runtime::Builder::new_multi_thread() .enable_all() .build().unwrap(); runtime.block_on(hello());}async fn hello() { tokio::time::sleep(Duration::from_secs(3)).await; println!(..." }, { "title": "Rust中的Arc与Rc", "url": "/superLish.github.io/posts/Rust%E4%B8%AD%E7%9A%84Arc%E4%B8%8ERc/", "categories": "CS, Rust", "tags": "Rust", "date": "2020-11-23 20:55:00 +0800", "snippet": "Rc单线程引用计数。不是线程安全的，如果需要线程间引用计数可用Arc。注意他们之间的实现区别。关键源码实现如下，重点可关注Clone和Drop以及new的实现细节。//! Single-threaded reference-counting pointers. &#39;Rc&#39; stands for &#39;Reference Counted&#39;.// This is repr(C) to future-proof against possible field-reordering, which// would interfere with otherwise safe ..." }, { "title": "树堆", "url": "/superLish.github.io/posts/%E6%A0%91%E5%A0%86/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2020-06-15 08:55:00 +0800", "snippet": "树堆树堆，是一种将二叉查找（搜索）树与堆两种数据结构结合在一起的一种数据结构，它首先是一颗二叉查找树同时满足一定的堆性质。我们知道二叉查找树与堆性质是有矛盾的，解决办法就是元素值以二叉查找树的性质分布，每个元素插入时都会随机生成一个优先级，优先级要满足堆性质中父节点大于等于子节点的性质，但不要求满足完全二叉树的堆性质。这样做的好处是：使二叉查找树保持一定的平衡性。 树堆的实现树堆的实现，主要是堆怎么融到二叉查找树中，我们知道维护堆性质，需要经常交换父子节点的值，这里如果直接交换会破坏二叉查找树的性质，怎么办呢？用旋转的方法，交换父子节点的值不是目的，目的是维护堆父节点大于子节点的性..." }, { "title": "PBFT共识算法", "url": "/superLish.github.io/posts/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/", "categories": "CS, 分布式", "tags": "分布式, 共识算法, 区块链", "date": "2020-06-10 13:25:00 +0800", "snippet": "拜占庭将军问题我们已知的共识算法，Paxos、Raft解决的都是非拜占庭问题，也就是可以容忍节点故障，消息丢失、延时、乱序等，但节点不能有恶意节点。但如何在有恶意节点存在的情况下达成共识呢？BFT共识算法就是解决这一问题的。即不但能容忍节点故障，还能容忍一定的恶意节点或者说拜占庭节点的存在。我们下面就学习一下BFT算法中的PBFT（Practical Byzantine Fault Tolerance）。BFT算法有非常多的变种，这里只学习PBFT，其他的可以举一反三。PBFTPBFT核心由3个协议组成：一致性协议、检查点协议、视图更换协议。系统正常运行在一致性协议和检查点协议下，只有当..." }, { "title": "中央银行与货币政策", "url": "/superLish.github.io/posts/%E4%B8%AD%E5%A4%AE%E9%93%B6%E8%A1%8C%E4%B8%8E%E8%B4%A7%E5%B8%81%E6%94%BF%E7%AD%96/", "categories": "读书笔记, 社会科学", "tags": "中央银行, 货币", "date": "2020-06-09 19:25:00 +0800", "snippet": "前言因为工作中涉及到数字货币的相关内容，数字货币作为货币中的一部分，由央行发行，所以就需要理解中央银行是怎么工作的，有那些职能，货币是怎么发行与流通的，对外经济贸易大学的MOOC《中央银行与货币政策》正好可以学习到这部分内容。第一章 现代中央银行的建立英格兰银行: 现代中央银行的鼻祖，英国中央银行，英格兰银行的发展就是中央银行三大职能的形成过程。中央银行的三大核心职能： 发行的银行、银行的银行、政府的银行。发行的银行是指拥有唯一的货币发行权。银行的银行职能是指中央银行充当商业银行和其他金融机构的最后贷款人。银行的银行这一职能体现了中央银行是特殊金融机构的性质，是中央银行作为金融体系核心的..." }, { "title": "自适应树", "url": "/superLish.github.io/posts/%E8%87%AA%E9%80%82%E5%BA%94%E6%A0%91/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2020-06-09 08:55:00 +0800", "snippet": "我们知道常见的树有二叉查找树、AVL树、红黑树，AVL树与红黑树都是为了解决二叉查找树可能存在的平衡行问题，让树在插入、删除节点时能使树做到一定的自平衡。但平衡不是目的，最终的目的是加快查找、插入、删除等操作的效率，AVL树与红黑树是通过使二叉树尽量平衡从而加快各种操作的效率，但是是不是唯一的方法呢？答案是不是的，如同自适应链表一样，同样，树也可以通过自适应树加快查找、插入、删除等的效率。实际应用中，并非所有元素的使用频率都相同，我们可以把使用频率高的元素上移到靠近树根的地方，使用频率低的元素就沉到树底部了，最后，使用频率高的元素分布在树的顶部，这样，一定程度上同样能实现各种操作效率的提..." }, { "title": "红黑树", "url": "/superLish.github.io/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2020-06-02 08:55:00 +0800", "snippet": "红黑树红黑树是一种自平衡二叉查找树，可以在O(log(n))时间内完成查找、插入和删除。相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。红黑树较AVL树等二叉树的不同在于其有个标识位（红色或者黑色），这个标识位的作用在于减少因不平衡造成的旋转操作，虽然此时树不是完全平衡二叉树，但依然有O(log(n)的时间效率。红黑树的性质红黑树要满足如下性质： Each node is either red or black. 节点是红色或者黑色 The root is black. 根是黑色 All leaves (NIL) are bla..." }, { "title": "堆", "url": "/superLish.github.io/posts/%E5%A0%86/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2020-06-01 08:55:00 +0800", "snippet": "堆堆是一种特别的树状数据结构。若满足以下特性，即可称为堆：“给定堆中任意节点P和C，若P是C的父节点，那么P的值会小于等于（或大于等于）C的值”。若父节点的值恒小于等于子节点的值，此堆称为最小堆；反之，称为最大堆。通常最用的是二叉堆，为二叉树的一种，有以下性质： 任意节点小于等于（或大于等于）它的子节点，最小元（或最大元）在堆的根上。 堆总是一颗完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。可以看到，二叉堆是一种部分排序，只对父子节点的排序做了限制，对左右子节点的大小排序则没有做限制。我们看一下堆的具体实现。堆的实现因为堆总是一颗完全树，所以其存储可以用数组（..." }, { "title": "Raft共识算法", "url": "/superLish.github.io/posts/Raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/", "categories": "CS, 分布式", "tags": "分布式, 共识算法", "date": "2020-05-29 13:25:00 +0800", "snippet": "Raft共识算法在分布式系统中是常用的共识算法之一，论文原文In Search of an Understandable Consensus Algorithm ，作者在论文中指出Poxas共识算法的两大问题，其一是难懂，其二是应用到实际系统存在困难。针对Paxos存在的问题，作者的目的是提出一个易懂的共识算法，论文中有单独一小节论述Raft是一个实用的、安全可用、有效易懂的共识算法。本文描述了Raft共识算法的细节，很多内容描述及引用图片均摘自论文原文。Raft概述我们主要分以下三部分对Raft进行讨论： Leader election——a new leader must be c..." }, { "title": "Rust异步之Future", "url": "/superLish.github.io/posts/Rust%E5%BC%82%E6%AD%A5%E4%B9%8BFuture/", "categories": "CS, Rust", "tags": "Rust, async", "date": "2020-05-09 20:55:00 +0800", "snippet": "对异步的学习，我们先从Future开始，学习异步的实现原理。等理解了异步是怎么实现的后，再学习Rust异步编程涉及的2个库（futures、tokio）的时候就容易理解多了。Futurerust中Future的定义如下，一个Future可以理解为一段供将来调度执行的代码。我们为什么需要异步呢，异步相比同步高效在哪里呢？就是异步环境下，当前调用就绪时则执行，没有就绪时则不等待任务就绪，而是返回一个Future，等待将来任务就绪时再调度执行。当然，这里返回Future时关键的是要声明事件什么时候就绪，就绪后怎么唤醒这个任务到调度器去调度执行。#[must_use = &quot;future..." }, { "title": "读《血色浪漫》", "url": "/superLish.github.io/posts/%E8%A1%80%E8%89%B2%E6%B5%AA%E6%BC%AB/", "categories": "读书笔记, 小说", "tags": "小说", "date": "2020-04-21 19:25:00 +0800", "snippet": "读《血色浪漫》后的一点感想这本书真是一本好书。讲述了文革一人成长历程，也是文化大革命时期社会的一个缩影。如果你去读历史书的话，对于文革的那段历史文字往往都是最少的，被一笔带过。读这本书你就能详尽的了解文革时期的社会。虽说文革距离现在已有半个世纪的了，但里面反映的社会问题，当下依旧存在。我小学中学时期，学校内外经常有打群架的，用的词居然和半个世纪前打架的词差不。什么“单挑还是群搂”，“给个面子”什么的，往往结局也可半个世纪前结局差不多，都是双方找人，约地方打架，然后中间某人调停，两边都认识，就握手言和了。随着社会的发展，外在变化了，但内在没有变，无论过去多少年，未来也是，都会存在以打架斗殴..." }, { "title": "读《中国历代政治得失》", "url": "/superLish.github.io/posts/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/", "categories": "读书笔记, 社会科学", "tags": "社会科学, 历史", "date": "2020-04-20 19:25:00 +0800", "snippet": "读《中国历代政治得失》有感《中国历代政治得失》，书很薄，但干货很多，对历史感兴趣的都可以读一下，它能增加你对历史的厚度，这本书最可贵的是并没有琐碎的列出中国历史上各个朝代的政治制度，而是结合当时的社会历史背景和当权者所面临的历史问题，先站在制度制定者的角度讲明为什么要制定这样的制度，而最后再从历史的角度看当时的政治制度的优劣得失。最典型的是处在中国历史中期的宋朝，宋朝是一个很矛盾的朝代，一方面宋代的文化科技兴盛，另一方面军事确是其软肋。难道宋朝人真的天生软弱？它所处的历史时期是唐亡后五代十国的乱世之后，宋朝的当权者所面临的最大问题是怎么解决灭亡唐代的繁镇割据问题，怎么解决失去燕云十六周后..." }, { "title": "读《两次全球大危机的比较研究》", "url": "/superLish.github.io/posts/%E4%B8%A4%E6%AC%A1%E5%85%A8%E7%90%83%E5%A4%A7%E5%8D%B1%E6%9C%BA%E7%9A%84%E6%AF%94%E8%BE%83%E7%A0%94%E7%A9%B6/", "categories": "读书笔记, 社会科学", "tags": "社会科学, 经济危机", "date": "2020-04-20 19:25:00 +0800", "snippet": "《两次全球大危机的比较研究》主编刘鹤，2013年出版。虽然是13年出版的，但现在回过头再读这本书，愈发觉的写的很有前瞻性。不在其位不谋其政，作为一枚工程师，因为下半年有可能会参与银行货币相关的项目，所以近期读了一些经管的书，读到这本书，书中的很多观点非常客观真实，也给了我很多新的认识，所以在这里推荐给大家。下面摘录书中“从经济金融理论视角看两次危机”中的部分内容：（一） 充分做好应对危机长期化的准备由于国际金融危机会长期化，“十二五”乃至更长时期，我国仍会处于应对危机的过程中，发展所处的外部环境不会太好，要增强忧患意识，做好长远谋划。要充分认识过去20年全球市场不断扩张的时期已经结束，国..." }, { "title": "读《中国近代史》", "url": "/superLish.github.io/posts/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2/", "categories": "读书笔记, 社会科学", "tags": "社会科学, 历史", "date": "2020-03-20 19:25:00 +0800", "snippet": "读《中国近代史》中国的近代史，是一部屈辱史，如果对中国近代史，仅限于教科书中的内容，那么对历史的认识可能很多都是错误的。因为对于一段历史，一个历史人物，很难用一句话去评述。这个世界并不是非黑即白的，更多的是灰色。拿李鸿章来说，在读中学历史的时候，读到一个个屈辱的外交条约基本都是李鸿章签署的，就给他贴了一个卖国贼的标签，真正读到历史，你会发现这个结论很矛盾，你说它是卖国贼，但他的很多看法和思想都超过了当时期的国人，他也为推动中国进步做出了一定的贡献，内心里是希望国家进步的，无奈却生在了清末那个灰暗的时代。这里不想对他的历史功过加以评述或给予一个明确的结论。只是想用这个清末的一个历史人物来说..." }, { "title": "ProtocolBuffers工作原理", "url": "/superLish.github.io/posts/ProtocolBuffers%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/", "categories": "CS, Backend", "tags": "", "date": "2020-03-04 08:55:00 +0800", "snippet": "这里记录一下学习与使用Protocol Buffer的笔记，优点缺点如何使用这里不再叙述，重点关注与理解Protocol Buffers的工作原理，其大概实现。我们经常使用Protocol Buffer进行序列化与反序列化。理解Protocol Buffer的工作原理，就要理解序列化与反序列化。 序列化：将数据结构或对象转换为二进制串的过程； 反序列化：序列化的逆过程；如何实现呢？核心有两点：编码 + 存储。数据在计算机间通过网络进行传输时，传输的是比特流，只有0和1,并没有你所定义的各种类对象等，你如果想将一个类对象传输到对方，怎么办呢？字符是用过ASCII码编码的，这里也可以设计..." }, { "title": "leveldb设计思路", "url": "/superLish.github.io/posts/leveldb/", "categories": "CS, Database", "tags": "leveldb", "date": "2020-02-09 13:25:00 +0800", "snippet": "本篇主要讲一下leveldb的工作原理，leveldb是一个非常有名的KV数据库，像比特币、以太坊等区块链底层的数据库都是leveldb数据库。所以我们需要学习一下leveldb的工作原理，理解在使用leveldb数据库时背后都发生了什么。如果让你自己设计，你怎么设计呢？如果让你设计一个KV数据库，你会怎么设计呢？ 首先要想一下这个问题，这里需要的是持久化存储的KV数据库，不是内存数据库。既然要持久存储，最终数据肯定是要落盘的，以文件的形式存储在磁盘上，也可以是其他存储介质。我们将key-Value数据写入磁盘后，后面查找的时候可以根据Key将磁盘文件中的Value读出来，这就是一个最最..." }, { "title": "跳跃链表", "url": "/superLish.github.io/posts/%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2020-01-14 08:55:00 +0800", "snippet": "跳跃链表的概念跳跃链表是有序链表的一个变种，在一个有序链表中，查找一个链表中的元素需要进行一次遍历，时间复杂度为O(n)，为了加快查找的过程，能够跳过某些元素呢？一个思路就是牺牲一定的空间换时间，对有序链表建立类似索引的结构加快查找过程，跳跃链表基本上就是通过维护一个多层次的链表，每一层链表中的元素是前一层链表元素的子集，搜索时，最开始在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻元素中间，这时，将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。原论文Skip Lists: A Probabilistic Alternative to Balanced Trees..." }, { "title": "对共识算法的若干思考", "url": "/superLish.github.io/posts/%E5%AF%B9%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%80%9D%E8%80%83/", "categories": "CS, 分布式", "tags": "分布式, 共识算法", "date": "2019-09-19 13:25:00 +0800", "snippet": "提起共识算法，比较典型的有Paxos、Raft、PBFT、Pow。他们之间有什么异同呢？都是解决什么问题，为什么会出现不同的共识算法呢？从面向的问题来看，Paxos与Raft解决的是非拜占庭问题，也就是说分布式系统中的节点没有恶意节点，可以容忍节点故障、消息可以延时、丢失、乱序，但不可以被篡改，而PBFT与Pow则是解决拜占庭问题，系统中存在一定数量的恶意节点，消息可以延时、丢失，但同样不可以被篡改。这是一个非常大的区别导致了他们解决问题的具体算法的不同，比如Raft与PBFT,Raft中的交互基本就是领导者节点和从节点之间的交互，从节点一切听从领导者节点的，但是PBFT却不止主从节点的..." }, { "title": "漫谈比特币网络", "url": "/superLish.github.io/posts/%E6%BC%AB%E8%B0%88%E6%AF%94%E7%89%B9%E5%B8%81%E7%BD%91%E7%BB%9C/", "categories": "CS, Blackchain", "tags": "Blockchain", "date": "2019-09-14 08:55:00 +0800", "snippet": "比特币解决的核心问题——“双重支付”可以说比特币最大的创新是用非中心化的方式解决了“双重支付”问题。之前已存在的交易系统，都是中心化的，由一个中心化的机构（例如银行）来管理记录一个账本，可以说非常简单粗暴的解决了“双重支付”，其安全保证是这个中心机构自身非常强大，很难攻破。而比特币解决这个问题，不是依靠单个节点的强大，而是依靠整个网络，通过整个网络维护一个公共的账本。可以这样理解，中心化机构解决“双重支付”，不是因为它是中心化机构，不是因为它自身强大安全系数高，而是因为它知道所有人的交易。同一笔钱，A发B，A又发给C，系统因为掌握了所有的交易，所以能够检测出第二笔交易是非法交易。但是这个..." }, { "title": "QuorumNWR算法", "url": "/superLish.github.io/posts/QuorumNWR%E7%AE%97%E6%B3%95/", "categories": "CS, 分布式", "tags": "分布式", "date": "2019-09-01 13:25:00 +0800", "snippet": "Quorum NWR算法在分布式场景中，扩展性、可靠性可以通过复制数据副本实现。如果多个服务分别向三个节点写数据，为了保证强一致，就必须要求三个节点全部写成功才返回。这样在读的时候可以读任意节点，就不会有不一致的情况了。但是，同步写三个节点的性能较低，如果换一个思路，一致性并不一定要在写数据的时候完成，可以在读的阶段决策，只要每次能读到最新的版本就可以了。这就是Quorum机制的核心思想。简单来说，Quorum机制就是要满足公式 W+R&amp;gt;N，式中N代表副本个数，W，又称写一致性级别， 表示成功完成W个副本更新，才完成写操作，R，又称读一致性级别，表示读操作至少要读取R个副本..." }, { "title": "分布式系统：向量时钟", "url": "/superLish.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%90%91%E9%87%8F%E6%97%B6%E9%92%9F/", "categories": "CS, 分布式", "tags": "分布式", "date": "2019-08-01 13:25:00 +0800", "snippet": "Lamport时钟存在的问题使用Lamport时间戳，只是比较事件a和b各自的时钟值C{a}和C{b}，无法说明它们之间的关系。也就是说，C{a}&amp;lt;C{b}不能说明事件a在事件b之前发生。比如下面的事件C4与A3，C{A3}&amp;lt;C{C4}，但是在时间上事件A3在C4之后发生。所以，Lamport时间戳的问题在于它不能捕获事件的因果关系，为了解决这个问题，有大神提出了向量时钟（Vector clock）。向量时钟Vector clock是在Lamport时间戳基础上演进的另一种逻辑时钟方法，它通过vector结构不但记录本节点的Lamport时间戳，同时也记录了其..." }, { "title": "哈希表原理", "url": "/superLish.github.io/posts/%E5%93%88%E5%B8%8C%E8%A1%A8%E5%8E%9F%E7%90%86/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2019-07-18 08:55:00 +0800", "snippet": "哈希表是最常用的数据结构之一，对于其用法，大家都非常熟悉，这里详细探讨一下其原理。哈希表的底层实际上是基于数组来存储的，当插入键值对时，并不是直接插入该数组中，而是通过对键进行Hash运算得到Hash值，然后和数组容量取模，得到在数组中的位置后再插入。取值时，先对指定的键求Hash值，再和容量取模得到底层数组中对应的位置，如果指定的键值与存贮的键相匹配，则返回该键值对，如果不匹配，则表示哈希表中没有对应的键值对。这样做的好处是在查找、插入、删除等操作可以做到O(1)，最坏的情况是O(n)，当然这种是最极端的情况，极少遇到。不管哪门语言，实现一个HashMap的过程均可分为三大步骤： 实..." }, { "title": "Merkle树", "url": "/superLish.github.io/posts/merkle%E6%A0%91/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2019-07-11 08:55:00 +0800", "snippet": "在分布式系统、P2P应用中或者是区块链中，会经常使用一种数据结构Merkle tree（默克尔树），这里我们将详细讨论一下这个常用数据结构。Merkle treeMerkle树看起来非常像二叉树，其叶子节点上的值通常为数据块的哈希值，而非叶子节点上的值，所以有时候Merkle tree也表示为Hash tree，如下图所示：在构造Merkle树时，首先要对数据块计算哈希值，通常，选用SHA-256等哈希算法。但如果仅仅防止数据不是蓄意的损坏或篡改，可以改用一些安全性低但效率高的校验和算法，如CRC。然后将数据块计算的哈希值两两配对（如果是奇数个数，最后一个自己与自己配对），计算上一层哈希..." }, { "title": "Bloom过滤器", "url": "/superLish.github.io/posts/Bloom%E8%BF%87%E6%BB%A4%E5%99%A8/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2019-07-10 08:55:00 +0800", "snippet": "提出一个问题在我们细述Bloom过滤器之前，我们先抛出一个问题：给你一个巨大的数据集（百万级、亿级……），怎么判断一个元素是否在此数据集中？或者怎么判断一个元素不在此数据集中？思考这个问题的时候，最先想到的可能是哈希表，在数据集规模较小的时候，这个方法是可行的，当然，数据集巨大的时候也可以采用分布式哈希表的方式。当数据集规模较大时，尤其是应用中只需要判断一个元素不在此数据集中的情况时，我们可以借鉴哈希表的思路，使用Bloom过滤器解决这个问题。既然我们只关心元素在不在，不关心元素值是什么，只要把元素映射为一个布尔值表示在不在就足够了。下面细述Bloom过滤器数据结构的设计。Bloom过滤..." }, { "title": "闪电网络", "url": "/superLish.github.io/posts/%E9%97%AA%E7%94%B5%E7%BD%91%E7%BB%9C/", "categories": "CS, Blackchain", "tags": "Blockchain", "date": "2019-07-10 08:55:00 +0800", "snippet": "闪电网络属于状态通道技术范畴，是区块链技术的一个发展方向之一，其核心思想是将本来在链上结算的交易在链下通过状态通道维护中间态，并且在发生纠纷时回到链上仲裁。链上仲裁的公平性和安全性在博弈论上保证了链下交易的对手不会作恶。通过这种方式实现扩容。下面是闪电网络技术概要。一、闪电网络——链下扩容方案【1】当前比特币网络的问题？我们都知道比特币系统的交易吞吐量是非常之低的，为了解决比特币系统交易吞吐量低的问题，闪电网络被提出，它并不是通过增加区块大小等链上扩容方案，而是一种通过离线交易形式的链下扩容方案。【2】闪电网络解决问题的思路——针对微支付场景要提升比特币系统的交易吞吐量，直接在链上广播大..." }, { "title": "Rust写时复制Cow", "url": "/superLish.github.io/posts/Rust%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6Cow/", "categories": "CS, Rust", "tags": "Rust", "date": "2019-06-25 20:55:00 +0800", "snippet": "写时复制（Copy on Write）技术是一种程序中的优化策略，多应用于读多写少的场景。主要思想是创建对象的时候不立即进行复制，而是先引用（借用）原有对象进行大量的读操作，只有进行到少量的写操作的时候，才进行复制操作，将原有对象复制后再写入。这样的好处是在读多写少的场景下，减少了复制操作，提高了性能。Rust中对应这种思想的是智能指针Cow&amp;lt;T&amp;gt;，定义如下：pub enum Cow&amp;lt;&#39;a, B&amp;gt; where B: &#39;a + ToOwned + &#39;a + ?Sized, { Borrowed(&..." }, { "title": "工作窃取算法work-stealing", "url": "/superLish.github.io/posts/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95work-stealing/", "categories": "CS, Backend", "tags": "", "date": "2019-06-20 08:55:00 +0800", "snippet": "工作中，我们经常会用到线程池，通常是任务产生后放到一个任务队列，线程池中的线程不断从任务队列中取任务执行，但这样设计在一些情况下并不是最优的，更常见的实现是基于work-stealing的线程池。work-stealing从字面理解即工作窃取，工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程图如下：那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，..." }, { "title": "Linux顺序锁", "url": "/superLish.github.io/posts/%E9%A1%BA%E5%BA%8F%E9%94%81/", "categories": "CS, Linux", "tags": "linux", "date": "2019-06-17 08:55:00 +0800", "snippet": "顺序锁与读写自旋锁非常类似，只是赋予了写者较高的优先级：即使在读者正在读的时候也允许写者继续运行。这样的好处是写者不用等待（除非另一个写者正在写），缺点是有些时候读者不得不反复多次读相同的数据直到它获得有效的副本。每个顺序锁就是包括两个字段的seqlock_t结构：一个类型为spinlock_t的lock字段和一个整型类型的sequence字段，第二个字段是一个顺序计数器。每个读者都必须在读数据前后两次读顺序计数器，并检查两次读到的值是否相同，如果不相同，说明新的写者已经开始写并增加了顺序计数器，因此暗示读者刚读到的数据是无效的。以下是Linux-2.6.30版本实现seqlock.h代..." }, { "title": "Linux自旋锁", "url": "/superLish.github.io/posts/%E8%87%AA%E6%97%8B%E9%94%81/", "categories": "CS, Linux", "tags": "linux", "date": "2019-06-13 08:55:00 +0800", "snippet": "自旋锁概念自旋锁应该是Linux内核中使用最多的锁了，其它锁很多都依赖自旋锁实现。自旋锁概念上简单，一个自旋锁是一个互斥设备，只能有2个值:”上锁”和”解锁”。它常常实现为一个整数值中的一个单个位，想获取一个特殊锁的代码测试相关的位，如果锁是可用的，这个”上锁”位被置位并且代码继续进入临界区；相反，如果这个锁已经被别人获得，代码进入一个紧凑的循环中反复检查这个锁，直到它变为可用。这个循环就是自旋锁的”自旋”部分。选择自旋锁，自旋等待的代价应该要尽可能的小于线程调度的代价。即，使用自旋锁的一个重要规则是自旋锁必须一直是尽可能短时间的持有。这个很好理解，因为你持有的时间越长，其他线程就不得不..." }, { "title": "对区块链技术几个问题的思考", "url": "/superLish.github.io/posts/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/", "categories": "CS, Blackchain", "tags": "Blockchain", "date": "2019-05-20 08:55:00 +0800", "snippet": "【1】为什么POW达成共识的周期较长？在像比特币这种公有链中，节点的数量是巨大的，而其基础P2P网络中每个节点都连接相对有限的节点，当有节点需要发送交易到全网时，其进行一次全广播是非常耗时的，当然产生新块后，全网广播也是非常耗时的。如果达成共识的时间设置的太短，对造成比特币频繁的分叉，造成系统不稳定，影响其系统效率。我想其系统设置成每10分钟才达成一次共识一定是有其合理性和必要性的，当然这只是我目前能考虑到的，应该不止上面的考虑。【2】POW共识算法的开放性POW共识算法的开放性使共识节点的加入退出无阻碍，无论是有100000个节点还是1 个节点，公有链都能正常工作；公平性使共识节点可以..." }, { "title": "分布式系统：时间、时钟和事件序列", "url": "/superLish.github.io/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E6%97%B6%E9%97%B4-%E6%97%B6%E9%92%9F%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BA%8F%E5%88%97/", "categories": "CS, 分布式", "tags": "分布式", "date": "2019-05-19 13:25:00 +0800", "snippet": "在程序中，我们经常需要知道事件序列，在单体应用中，事件序列是较为简单的，最简单的办法就是用时间戳，但在分布式系统中，事件序列是很困难的，Leslie Lamport大神在论文Time, Clocks, and the Ordering of Events in a Distributed System讨论了在分布式系统中时间、时钟和事件序列的问题。【1】分布式系统中物理时钟存在的问题逻辑时钟是相对物理时钟这个概念的，为什么要提出逻辑时钟，因为物理时钟在分布式系统中存在一系列问题。在一台机器上的多个进程可以从一个物理时钟中获取时间戳，不管这个物理时钟是否准确，只要是从一个物理时钟获取时间戳..." }, { "title": "基础数论——同余式、剩余类", "url": "/superLish.github.io/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA-%E5%90%8C%E4%BD%99%E5%BC%8F-%E5%89%A9%E4%BD%99%E7%B1%BB/", "categories": "CS, Crypto", "tags": "math, crypto", "date": "2019-04-15 08:55:00 +0800", "snippet": "同余式【定义】任给\\(a,b,m\\in Z\\)，如果\\(a\\)和\\(b\\)相差一个\\(m\\)的倍数，即\\(m|a-b\\)，就说\\(a\\)与\\(b\\)模\\(m\\)同余，记为\\(a\\equiv b\\ (\\mod m)\\)，并称\\(m\\)为同余式的模。 这里\\(m\\) \\(\\vert\\) \\(a-b\\)，可表示为\\(mq=a-b\\)，所以 \\(a=mq+b\\) .【定理】任给正整数\\(m\\)，我们有： 整数\\(a\\)与\\(b\\)模\\(m\\)同余当且仅当它们被\\(m\\)除所得的余数相同. 模\\(m\\)同余是\\(Z\\)上的等价关系，即有： \\(a\\equiv a \\ (\\..." }, { "title": "基础数论——算数基本定理、欧几里得算法、丢番图方程", "url": "/superLish.github.io/posts/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA-%E7%AE%97%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95-%E4%B8%A2%E7%95%AA%E5%9B%BE%E6%96%B9%E7%A8%8B/", "categories": "CS, Crypto", "tags": "math, crypto", "date": "2019-04-08 08:55:00 +0800", "snippet": "整除【定义】 对于\\(a,b \\in Z\\)，如果有\\(q \\in Z\\)使得\\(aq=b\\)，则称\\(a\\)整除\\(b\\)，记为\\(a|b\\).关于整除有如下结论：若\\(c=k_1a+k_2b\\)， \\(e\\) \\(\\vert\\) \\(a\\) ， 且\\(e\\) \\(\\vert\\) \\(b\\)，则 \\(e\\) \\(\\vert\\) \\(c\\).最大公因子【定义】 所有同时整除\\(a\\)和\\(b\\)的整数中，最大的那个，称为\\(a\\)和\\(b\\)的最大公因子，记为\\((a,b)\\)，也可记为\\(gcd(a,b)\\).【引理】 设\\(a=bq+c\\)，这里\\(a,b,c,q\\in Z\\)，则\\..." }, { "title": "以太坊RLPx传输协议", "url": "/superLish.github.io/posts/%E4%BB%A5%E5%A4%AA%E5%9D%8ARLPx%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/", "categories": "CS, Blackchain", "tags": "Blockchain, Ethereum", "date": "2019-03-07 08:55:00 +0800", "snippet": " 本文主要内容翻译自：The RLPx Transport Protocol，其中添加了一些个人的理解，由于密码学水平有限，不正确之处望指正。另外原文可能已经更新，最新内容请直接阅读原文。本文档定义了RLPx传输协议，一种基于TCP的用于Ethereum节点间通信的传输协议。该协议适用于任意内容的加密帧，但它通常用于承载devp2p应用程序协议。节点标识所有加密操作都基于secp256k1椭圆曲线。每个节点都需要维护一个在会话间保存和复原的静态私钥。建议私钥只能手动重置，例如，通过删除文件或数据库条目。ECIES加密ECIES(Elliptic Curve Integrated Enc..." }, { "title": "自组织链表", "url": "/superLish.github.io/posts/%E8%87%AA%E7%BB%84%E7%BB%87%E9%93%BE%E8%A1%A8/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2019-01-14 08:55:00 +0800", "snippet": "引入跳跃链表的目的是为了加速查找过程。而加速策略其中一个非常重要的观点就是并非所有的元素使用的频率都相同。我们自然希望高频使用的元素在链表的头部，而低频的在链表尾部。单向链表和双向链表需要进行顺序查找以定位某个元素，还可以用某种方法动态地组织链表，从而提高查找效率。有许多不同的方法可以组织链表，比较常见的有如下四种： 前移法：在找到需要的元素之后，把它放到链表的开头。 // 有点LRU缓存的感觉 换位法：在找到需要的元素之后，只要它不在链表的开头就与其前驱节点交换位置。 计数法：根据元素被访问的次数，对链表进行排序。 排序法：根据被考察信息自身的属性，对链表..." }, { "title": "Elasticsearch定时删除索引", "url": "/superLish.github.io/posts/Elasticsearch%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95/", "categories": "CS, ELK", "tags": "ELK", "date": "2018-12-08 13:25:00 +0800", "snippet": "在Elasticsearch中，我们常常需要按时间来建立索引，以便我们今后的使用与管理，同时我们也经常按时间去删除一些老的数据。比如只保留最近3天的数据，只需将超多3天的索引数据删除就好了。删除索引有很多种方法，你可以自己编写脚本删除索引，也可以手动删除索引curl -XDELETE http://127.0.0.1:9200/index-name，这里使用Curator工具删除索引。CuratorCurator 是elasticsearch 官方的一个索引管理工具，可以通过配置文件的方式帮助我们对指定的一批索引进行创建/删除、打开/关闭、快照/恢复等管理操作。 安装参考文档： Cur..." }, { "title": "使用Logstash解析日志", "url": "/superLish.github.io/posts/%E4%BD%BF%E7%94%A8Logstash%E8%A7%A3%E6%9E%90%E6%97%A5%E5%BF%97/", "categories": "CS, ELK", "tags": "ELK", "date": "2018-12-07 13:25:00 +0800", "snippet": " 本文翻译自：Logstash Reference [6.5] » Getting Started with Logstash » Parsing Logs with Logstash在存储你的第一个事件一节中，我们创建了一个简单的Logstash管道示例来测试你已安装运行的Logstash。在生产环境中，Logstash管道会非常复杂：一般包含一个或多个输入，过滤器，输出插件。在本章节，你将创建一个Logstash管道：Filebeat采集Apache web日志数据作为输入，解析输入的日志，创建特定的字段，然后将解析后的数据写入Elasticsearch集群中。您将在配置文件中进行..." }, { "title": "Logstash参考指南：存储你的第一个事件", "url": "/superLish.github.io/posts/Logstash%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97-%E5%AD%98%E5%82%A8%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6/", "categories": "CS, ELK", "tags": "ELK", "date": "2018-12-06 13:25:00 +0800", "snippet": " 本文翻译自：Logstash Reference [6.5] » Getting Started with Logstash » Stashing Your First Event。首先，我们通过一个最简单的Logstash管道来测试Logstash是否已经安装成功。Logstash管道有两个必需的元素：输入和输出，以及一个可选元素：过滤器。输入插件从源消耗数据，过滤器插件根据您指定的内容修改数据，输出插件将数据写入目标。让我们运行以下最基础管道来测试Logstash安装成功与否，如下所示：cd logstash-6.5.1bin/logstash -e &#39;input { s..." }, { "title": "Filebeat工作原理", "url": "/superLish.github.io/posts/Filebeat%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/", "categories": "CS, ELK", "tags": "ELK", "date": "2018-12-05 13:25:00 +0800", "snippet": " 本文翻译自：Filebeat Reference [6.5] » How Filebeat works。在本章节，你将会学到Filebeat的关键组成部分以及它们是如何组织工作的。理解这些概念将有助于你对自己的Filebeat用例进行更优的配置。Filebeat主要由2部分构成：输入嗅探(inputs)和收集器(harvester)。这些组件组合在一起，追踪数据文件并且将至发送到你指定的目的地。 原文中inputs这里译为输入嗅探，harvester译为收集器仅是个人理解，可能不太准确。什么是收集器？收集器负责读取数据文件的内容。收集器会逐行的读取文件并将读到的数据发送到输出。每个..." }, { "title": "Filebeat概述", "url": "/superLish.github.io/posts/Filebeat%E6%A6%82%E8%BF%B0/", "categories": "CS, ELK", "tags": "ELK", "date": "2018-12-04 13:25:00 +0800", "snippet": " 本文翻译自：Filebeat Reference [6.5] » Filebeat overview。Filebeat是一个轻量级的日志数据收集传输工具(shipper)。Filebeat安装在用户服务器上，监测追踪用户指定的日志文件或目录，收集日志，然后将之传输到Elasticsearch或Logstash以便进行后面的索引工作。接下来让我们看一下Filebeat是如何工作的：当启动Filebeat时，会开启一个或多个负责监测追踪指定目录的日志数据输入嗅探器(inputs)。对嗅探器定位到的每个日志数据文件，会各启动一个收集器(harvester)。收集器会逐次读取新的日志数据并将..." }, { "title": "Filebeat+Logstash+Elasticsearch+Kibana安装", "url": "/superLish.github.io/posts/Filebeat+Logstash+Elasticsearch+Kibana%E5%AE%89%E8%A3%85/", "categories": "CS, ELK", "tags": "ELK", "date": "2018-12-03 13:25:00 +0800", "snippet": "Filebeat安装Filebeat使用Go语言，无须安装java运行环境。安装Filebeat从官网下载安装包，解压后放到你想要安装的目录就可以了curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.5.1-linux-x86_64.tar.gztar xzvf filebeat-6.5.1-linux-x86_64.tar.gz运行修改配置文件filebeat.yml启动./filebeat -c filebeat.yml（测试学习阶段可以这样启动）Logstash安装前期准备确保JDK..." }, { "title": "对Rust所有权、借用及生命周期的理解", "url": "/superLish.github.io/posts/%E5%AF%B9Rust%E6%89%80%E6%9C%89%E6%9D%83-%E5%80%9F%E7%94%A8%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/", "categories": "CS, Rust", "tags": "Rust", "date": "2018-11-08 20:55:00 +0800", "snippet": "Rust的内存管理中涉及所有权、借用与生命周期这三个概念，下面是个人的一点粗浅理解。一、从内存安全的角度理解Rust中的所有权、借用、生命周期要理解这三个概念，你首要想的是这么做的出发点是什么——内存安全，这是Rust非常强调的一点。可以这么理解，所有权、借用与生命周期很大程度上是为内存安全而设计的。所有权，从内存安全的角度思考，如果一个实例有多个所有者，这个实例就很可能不安全，多个所有者都可能操作这个实例产生竞争，解决的办法是让他只有一个所有者，这样就无论如何也无法产生竞争(Data race)。新问题来了，如果其他人想访问这个实例怎么办？借用。借用，有点类似与引用，可以理解为我不去获..." }, { "title": "记一次排查内存泄漏的过程", "url": "/superLish.github.io/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E8%BF%87%E7%A8%8B/", "categories": "CS, Rust", "tags": "Rust", "date": "2018-09-26 20:55:00 +0800", "snippet": "排查过程程序测试运行过程中，其中一个进程被Linux系统给杀掉了，查看系统日志，发现是进行占用内存过大而触发Linux OOM给杀掉了。重启反复几次后均被杀掉，发现是内存泄漏问题。另发现有的时候有内存泄漏，有的时候没有内存泄漏。针对这种情形，首先想到的是进行重现，然后使用工具检测排查，同时检测内存，统计出内存泄漏的状况，发现内存泄漏呈线性增长，大概5kb/s。有了这个数据后就可以大概想一下，哪里可能会出现每秒泄漏5kb/s。因为是随着时间呈非常有规律的线性增长，最先想到的是程序中有个超时1s定时执行一个连接操作。把这段代码注释掉后，没有再发现内存泄漏，从而对泄露位置初步定位，同时也明白了..." }, { "title": "ECDSA详解", "url": "/superLish.github.io/posts/ECDSA%E8%AF%A6%E8%A7%A3/", "categories": "CS, Crypto", "tags": "crypto", "date": "2018-09-03 08:55:00 +0800", "snippet": "ECDSA(Elliptic Curve Digital Signature Algorithm)，椭圆曲线数字签名算法。椭圆曲线数字签名生成假设Alice希望对消息\\(m\\)进行签名，所采用的椭圆曲线参数为\\(D=(p,a,b,G,n,h)\\)，对应的密钥对为\\((k,Q)\\)，其中\\(Q\\)为公钥，\\(k\\)为私钥。Alice将按如下步骤进行签名： 产生一个随机数\\(d\\)，\\(1 \\leq d \\leq n-1\\). （签名算法首先生成一个临时私公钥对，该临时密钥对用于计算\\(r\\)和\\(s\\)值。） 计算\\(dG=(x_1,y_1)\\)，将\\(x_1..." }, { "title": "AVL树", "url": "/superLish.github.io/posts/AVL%E6%A0%91/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2018-09-01 08:55:00 +0800", "snippet": "AVL树在二叉查找树的相关操作中，例如，插入、查找、删除、最大值、最小值等的时间复杂度为O(h)，为了避免算法的最坏情况，我们应当使二叉树平衡，以降低树的高度。DSW算法能够实现树的平衡，但有其局限性，只能做全局的平衡，当节点又有变化时，需要重新进行平衡（这个平衡的过程代价较大，等于是一整颗树都参与了平衡过程）。有没有更好的办法呢？AVL树就是其中一种。AVL树是一种自平衡二叉查找树，其要求每个节点左右子树的高度差最大为1。下图所示是一颗AVL树，可以看到，AVL树不保证得到的树是完全平衡树。这里需要定义平衡因子，即右子树的高度减去左子树的高度。其实现思路，是在进行插入或删除节点时探测有..." }, { "title": "线索树", "url": "/superLish.github.io/posts/%E7%BA%BF%E7%B4%A2%E6%A0%91/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2018-08-15 08:55:00 +0800", "snippet": "线索树在二叉查找树中，深度优先遍历的实现有递归和非递归两种方法，非递归使用了栈，递归方式本质上也是栈的形式，当树非常大且树不平衡时，最坏的情况是栈存储了整颗树，这是非常不好的情况。有没有不用栈的方式实现深度优先遍历呢？线索树是其中的一种方法。遍历本质上是将非线性结构转为线性结构，这里可以认为遍历的过程是类似于一个链表的访问过程，每个节点都有前驱和后继（特殊节点除外）。如果二叉查找树节点中存储一个前驱和后继，这个问题就解决了。但是如果新增两个指针指向前驱和后继空间代价较大，可以利用二叉查找树中空闲的指针域外加一个标识位来表明这是一个右子节点指针还是一个后继节点指针。具体实现时，在插入节点时..." }, { "title": "ECIES详解", "url": "/superLish.github.io/posts/ECIES%E8%AF%A6%E8%A7%A3/", "categories": "CS, Crypto", "tags": "crypto", "date": "2018-08-02 08:55:00 +0800", "snippet": "本文描述了使用ECIES加解密时的计算步骤。ECIES加密可以认为是先基于ECDH协商密钥，再用刚刚协商一致的密钥进行对称加密，这样能够结合非对称加密和对称加密的优点。前提为了向Bob发送ECIES加密信息，Alice需要以下信息： 密码学套件（ \\(KDF\\)，\\(MAC\\)，对称加密\\(E\\)） 椭圆曲线\\((p,a,b,G,n,h)\\) Bob的公钥：\\(K_B\\)（\\(K_B=k_BG\\)，\\(k_B\\in[1,n-1]\\)） 共享信息：\\(S_1\\)，\\(S_2\\) 无穷远点\\(O\\)加密步骤Alice加密消息\\(m\\)的步骤如下： 生成随机数\\(r\\in[1,n-..." }, { "title": "Dijkstra算法", "url": "/superLish.github.io/posts/Dijkstra%E7%AE%97%E6%B3%95/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2018-07-30 08:55:00 +0800", "snippet": "在图的应用中，最常用的就是求解各种条件下的最短路径问题，这里Dijkstra算法是求解有权（权值为非负值）图的单源最短路径算法，即只能求出某点到其它点最短距离，并不能得出任意两点之间的最短距离。经典实现伪代码如下： 1 function Dijkstra(Graph, source): 2 3 create vertex set Q 4 5 for each vertex v in Graph: 6 dist[v] ← INFINITY 7 prev[v] ← UNDE..." }, { "title": "树的平衡dsw算法", "url": "/superLish.github.io/posts/%E6%A0%91%E7%9A%84%E5%B9%B3%E8%A1%A1DSW%E7%AE%97%E6%B3%95/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2018-07-24 08:55:00 +0800", "snippet": "树适合于表示某些领域的层次结构（比如Linux的文件目录结构），使用树进行查找比使用链表快的多，理想情况下树的查找复杂度O(log(N))，而链表为O(N)，但理想情况指的是什么情况呢？一般指树是完全平衡的时候。哪最坏的情况是什么呢？就是树退化为链表的时，这时候查找的复杂度与链表相同。就失去了树结构的意义。所以树的平衡是非常重要的，这一节我们主要讨论树的平衡问题。如果树中任一节点的两个子树的高度差为0或者1，该二叉树就是高度平衡的。 上图中，A是平衡二叉搜索树，B是不平衡的，C直接退化为链表了。为保持树的平衡，有两种策略，一种是全局的，即当插入和删除操作完毕后，对树进行重建，全局调整树为..." }, { "title": "图的表示与遍历", "url": "/superLish.github.io/posts/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E9%81%8D%E5%8E%86/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2018-07-24 08:55:00 +0800", "snippet": "图是非常重要的数据结构，现实中的很多问题都归结于图的问题，这里我们讨论一下图，关于图的基础：顶点、边等概念可参考文档：Graph Data Stucture，这里不再细述。图的表示图有两种表示方法：邻接矩阵、邻接链表。不同的场景及算法可能需要不同的图表示方式，一般情况下当结点数量非常庞大时，会造成矩阵非常稀疏，空间开销会较大，此时使用邻接链表的表示方式会占用较少的空间。而如果是稠密矩阵或者需要快速判断任意两个结点是否有边相连等情况，可能邻接矩阵更合适。邻接矩阵#include&amp;lt;iostream&amp;gt;using namespace std;// 无向有权图class..." }, { "title": "ECDH密钥交换", "url": "/superLish.github.io/posts/ECDH%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2/", "categories": "CS, Crypto", "tags": "crypto", "date": "2018-07-01 08:55:00 +0800", "snippet": "前面一篇讲过DH密钥交换算法，ECDH（Elliptic Curve Diffie-Hellman）顾名思义就是ECC+DH，安全性保证由椭圆曲线离散对数难题来保证。其思想与DH一致。椭圆曲线密码学椭圆曲线密码学是属于非对称密码学的。其公私钥计算公式如下： 私钥是一个随机数\\(d\\)，取值范围在\\({1,...,n-1}\\)，其中\\(n\\)是子群的阶 公钥是点\\(H=dG\\)，\\(G\\)是子群的基点如果我们知道私钥\\(d\\)和椭圆曲线参数\\(G\\)，求公钥\\(H\\)是很容易的，但是只知道公钥\\(H\\)和椭圆曲线参数\\(G\\)，求解私钥\\(d\\)是非常困难的，需要解决离散对数难题，椭圆..." }, { "title": "二叉查找树的morris遍历算法", "url": "/superLish.github.io/posts/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84Morris%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2018-06-15 08:55:00 +0800", "snippet": "二叉查找树的遍历方法有多种，递归实现，利用栈实现，线索树实现，这几种遍历方法，其时间复杂度都为O(n)，而空间复杂度递归和栈为O(h)，线索树需要额外的标识位来表明是线索还是节点指针，空间复杂度为O(n)，当节点数量非常大时，树高h = log(n)仍然较大，有没有其他的遍历算法，其空间效率更高呢？这就是Morris算法，其时间复杂度为O(n)，空间复杂度做到了O(1)。这是较其他几种遍历方法最不同的地方。其算法的思想有点类似线索树，只不过线索树中的后继指针是一直存储在节点中，而morris算法中也有后继指针，但却是临时的，即遍历的过程中生成临时后继指针，节点遍历过后检测到其右子节点指针..." }, { "title": "Diffie-Hellman密钥交换", "url": "/superLish.github.io/posts/Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2/", "categories": "CS, Crypto", "tags": "crypto", "date": "2018-06-11 08:55:00 +0800", "snippet": "DH密钥交换是一种安全协议，它可以让双方在不安全的信道上创建一个密钥。双方互相发送的数据就算被第三方知晓，也无法知道加密信息的密钥。其解决问题的主要思想可以用下图来解释：Alice和Bob想要协商出一个只有它们两人知道的颜色，不能让第三方知道，怎么办呢？解决办法如下： 先从它们共同拥有的颜色（图中为黄色）开始，这个黄色是大家都知道的，第三方知道也没有关系。 Alice选了一个只有自己知道的颜色（图中为红色），并将之混入大家知道的黄色中，形成新的颜色（图中为棕色）。 Bob也选了一个只有自己知道的颜色（图中为淡绿色），并将之混入大家都知道的黄色中，形成新的颜色（图中为浅蓝色）。 A..." }, { "title": "谈谈TCP", "url": "/superLish.github.io/posts/TCP%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%80%BB%E8%BE%91/", "categories": "CS, Network", "tags": "TCP/IP", "date": "2018-06-06 13:25:00 +0800", "snippet": "为什么需要TCP？TCP是提供可靠的数据流传输协议， 用于端到端之间的通信。如果没有TCP，仅用UDP，在设计的时候，你就需要思考，如果报文丢失了怎么办，发送方不停的在发数据报，接收方来不及处理怎么办？造成网络拥堵怎么办？因为IP数据报在网络上传输经过的路径不一定相同，出现乱序怎么办。这都是要考虑的，除非业务方能容忍报文丢失乱序能问题。TCP很大程度上就是解决上面的问题。TCP的工作逻辑TCP是面向连接的，发送数据前，需要进行握手，握手的过程就是确认对方在不在，交换信息的过程，交换什么信息呢？最重要的是各自的序列号和窗口信息。怎么解决报文丢失的问题？ TCP的其中一个最大的目标就是可靠，..." }, { "title": "以太坊节点发现协议", "url": "/superLish.github.io/posts/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%8A%82%E7%82%B9%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE/", "categories": "CS, Blackchain", "tags": "Blockchain, Ethereum", "date": "2018-05-31 08:55:00 +0800", "snippet": "我们知道以太坊是一个公有链，其节点可以自由的加入与退出，但是有一个问题，就是我不知道以太坊网络中正在运行有那些节点，也不知道其节点的信息，但是又需要加入到以太坊网络中，怎么解决这个问题呢？以太坊给出的解决方法是先通过一个已知的节点加入到网络，然后通过节点发现协议发现更多的节点，从而建立连接，以动态维持本节点稳定运行所需的最低连接数。本档前部分翻译自以太坊定义的节点发现协议（版本4），后半部分给出了源码实现的大致流程，以帮助理解。以太坊节点信息的存储采用的是Kademlia分布式哈希表。理解节点发现协议主要是理解分布式哈希表的原理，再加上定义的节点间通信的报文格式，节点ID的定义，距离的计..." }, { "title": "分组密码及AES算法初识", "url": "/superLish.github.io/posts/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%8F%8AAES%E7%AE%97%E6%B3%95%E5%88%9D%E8%AF%86/", "categories": "CS, Crypto", "tags": "crypto, AES", "date": "2018-05-19 08:55:00 +0800", "snippet": "对称密码算法常用对称密码算法AES、Blowfish、DES、RC5等，DES目前认为已不安全，当前使用最多的是AES加密算法，因其应用的广泛，目前主流CPU已经实现了AES-NI（全称是：Advanced Encryption Standard New Instructions），这是针对AES加密算法的硬件加解密CPU指令集。通过硬件加速，能实现吞吐量成倍的提升。所以这里重点学习AES加密算法。 这里还需要列出常见的轻量级分组密码算法：LET、GOST、TWINE等，这类算法主要应用在对硬件资源要求比较敏感的情况，比如物联网等。分组密码算法分组密码算法只能加密固定长度的分组，但是需..." }, { "title": "Fabric网络组织与主节点选举", "url": "/superLish.github.io/posts/Fabric%E7%BD%91%E7%BB%9C%E7%BB%84%E7%BB%87%E4%B8%8E%E4%B8%BB%E8%8A%82%E7%82%B9%E9%80%89%E4%B8%BE/", "categories": "CS, Blackchain", "tags": "Blockchain, Fabric", "date": "2018-05-16 08:55:00 +0800", "snippet": "一、Fabric网络组织Fabric网络组织按如下结构组成：Fabric网络–&amp;gt;Channel通道–&amp;gt;组织（成员）–&amp;gt;节点。即整个网络由数个通道组成，每个通道都由多个组织构成，而每个组织内部由数个节点组成（可能由功能或其他划分方式分为多个节点）。如下图所示：二、主节点（leader peer）选举一个组织（其实是成员）在一个通道上可以有多个Peer节点，这时候为了提高通信效率，需要选举出来一个主节点（leader）作为代表和排序服务节点通信，负责从排序服务节点处获取最新的区块并在组织内部同步。有如下两种方式：1. 静态指定配置文件中配置 #..." }, { "title": "AES加密算法原理", "url": "/superLish.github.io/posts/AES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/", "categories": "CS, Crypto", "tags": "crypto", "date": "2018-04-09 08:55:00 +0800", "snippet": "密码学博大精深，这里所说的AES加密算法原理可以理解为AES工作流程，至于为什么这么设计，这么设计为什么是安全的，有待今后的学习与思考。分组密码设计的两个原则分组密码设计的两个原则：混淆(confusion)和扩散(diffusion)，其目的是抗击敌手对密码系统的统计分析。 混淆是使密文的统计特性与密钥的取值之间的关系 尽可能复杂化，以使密钥和明文以及密文之间的依赖性对密码分析者来说是无法利用的。 扩散的作用就是将每一位明文的影响尽可能迅速地作用到较多的输出密文位中，以便在大量的 密文中消除明文的统计结构，并且使每一位密钥的影响尽可能迅速地扩展到较多的密文位中，以防对密钥进行逐段破..." }, { "title": "TOML学习笔记", "url": "/superLish.github.io/posts/TOML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/", "categories": "CS, Backend", "tags": "", "date": "2018-03-06 08:55:00 +0800", "snippet": "常见的配置文件格式有ini，yaml，toml等，今天学习一下toml。TOML（Tom’s Obvious, Minimal Language），因为它的作者是 GitHub联合创始人Tom Preston-Werner 。github地址：https://github.com/toml-lang/toml。ini,yaml,toml的对比In some ways TOML is very similar to JSON: simple, well-specified, and maps easily to ubiquitous data types. JSON is great fo..." }, { "title": "YAML学习笔记", "url": "/superLish.github.io/posts/YAML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/", "categories": "CS, Backend", "tags": "", "date": "2018-03-01 08:55:00 +0800", "snippet": "接触yaml是用来做配置文件的，所以首要的是学习yaml的基本编写规则，暂不做太深入的学习。学习yaml，可以参考wiki，基本各方面都讲到了。下面是摘自wiki的： *YAML (YAML Ain’t Markup Language) is a human-readable data serialization language. It is commonly used for configuration files, but could be used in many applications where data is being stored (e.g. debugging o..." }, { "title": "docker及docker-compose安装", "url": "/superLish.github.io/posts/docker%E5%8F%8Adocker-compose%E5%AE%89%E8%A3%85/", "categories": "CS, Docker", "tags": "docker, docker-compose", "date": "2018-02-09 13:25:00 +0800", "snippet": "安装docker步骤一、SET UP THE REPOSITORY1、Update the apt package index:sudo apt-get update2、Install packages to allow apt to use a repository over HTTPS:sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common3、 Add Docker’s official GPG key:curl -fsSL..." }, { "title": "Docker更换为国内镜像", "url": "/superLish.github.io/posts/Docker%E6%9B%B4%E6%8D%A2%E4%B8%BA%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/", "categories": "CS, Docker", "tags": "docker", "date": "2018-02-09 13:25:00 +0800", "snippet": "更换原因在国内访问 Docker 官方的镜像，一直以来速度都慢如蜗牛。为了快速访问 Docker 官方镜像都会配置三方加速器，目前常用三方加速器有：网易、USTC、DaoCloud、阿里云。现在 Docker 官方针对中国区推出了镜像加速服务。通过 Docker 官方镜像加速，国内用户能够以更快的下载速度和更强的稳定性访问最流行的 Docker 镜像。如何使用官方镜像Docker 中国官方镜像加速可通过 registry.docker-cn.com 访问。目前该镜像库只包含流行的公有镜像，而私有镜像仍需要从美国镜像库中拉取。可以使用以下命令直接从该镜像加速地址进行拉取。docker pu..." }, { "title": "Rust双重循环break的问题", "url": "/superLish.github.io/posts/Rust%E5%8F%8C%E9%87%8D%E5%BE%AA%E7%8E%AFbreak%E7%9A%84%E9%97%AE%E9%A2%98/", "categories": "CS, Rust", "tags": "Rust", "date": "2017-12-19 20:55:00 +0800", "snippet": "在单循环中使用break跳出循环，但如果遇到双重循环或者更多重循环时怎么办呢？与其他语言类似，Rust使用标记标识跳出指定循环。如下所示：fn main() { let a = vec![1;5]; let b = vec![2;6]; &#39;outer: for i in a { println!(&quot;{}&quot;, i); &#39;inner: for j in b.iter() { print!(&quot;{}&quot;, j); break &#39;outer; ..." }, { "title": "Rust关联类型与默认泛型类型参数", "url": "/superLish.github.io/posts/Rust%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0/", "categories": "CS, Rust", "tags": "Rust", "date": "2017-10-21 20:55:00 +0800", "snippet": "一、关联类型（associated types）我们阅读Rust程序的时候，有时候会出现如下的代码：trait Iterator { type Item; fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;;}下面是上面代码的注解：Iterator trait有一个关联类型 Item。Item是一个占位类型，同时next方法会返回 Option&amp;lt;Self::Item&amp;gt;类型的值。这个 trait的实现者会指定 Item的具体类型。这里的type用法就是关联类型。..." }, { "title": "Rust完全限定语法与消歧义：调用相同名称的方法", "url": "/superLish.github.io/posts/Rust%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%B6%88%E6%AD%A7%E4%B9%89-%E8%B0%83%E7%94%A8%E7%9B%B8%E5%90%8C%E5%90%8D%E7%A7%B0%E7%9A%84%E6%96%B9%E6%B3%95/", "categories": "CS, Rust", "tags": "Rust", "date": "2017-10-19 20:55:00 +0800", "snippet": "Rust既不能避免一个trait与另一个trait拥有相同名称的方法，也不能阻止为同一类型同时实现这两个trait。甚至可以直接在类型上实现开始已经有的同名方法！当然，当调用这些同名方法时，你必须要告诉Rust我们使用哪一个。下面示例代码说明了具体用法：pub trait Airplane { fn speed(&amp;amp;self){ println!(&quot;airplane default speed=800&quot;); } fn state(){ println!(&quot;fly state&quot;); }..." }, { "title": "Rust生命周期bound用于泛型的引用", "url": "/superLish.github.io/posts/Rust%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9Fbound%E7%94%A8%E4%BA%8E%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%BC%95%E7%94%A8/", "categories": "CS, Rust", "tags": "Rust", "date": "2017-10-17 20:55:00 +0800", "snippet": "在实际编程中，可能会出现泛型引用这种情况，我们会编写如下的代码：struct Inner&amp;lt;&#39;a, T&amp;gt; { data: &amp;amp;&#39;a T,}会产生编译错误：error[E0309]: the parameter type `T` may not live long enough --&amp;gt; src/main.rs:16:5 |15 | struct Inner&amp;lt;&#39;a, T&amp;gt; { | - help: consider adding an ex..." }, { "title": "RefCell和内部可变性", "url": "/superLish.github.io/posts/RefCell%E5%92%8C%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7/", "categories": "CS, Rust", "tags": "Rust", "date": "2017-10-16 20:55:00 +0800", "snippet": "RefCellRust在编译阶段会进行严格的借用规则检查，规则如下： 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用。 引用必须总是有效。 即在编译阶段，当有一个不可变值时，不能可变的借用它。如下代码所示：fn main() { let x = 5; let y = &amp;amp;mut x;}会产生编译错误：error[E0596]: cannot borrow immutable local variable `x` as mutable --&amp;gt; src/main.rs:32:18 |31 | let x..." }, { "title": "椭圆曲线密码算法概述", "url": "/superLish.github.io/posts/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/", "categories": "CS, Crypto", "tags": "crypto", "date": "2017-10-03 08:55:00 +0800", "snippet": "椭圆曲线密码算法椭圆曲线密码算法（Elliptic Curve Cryptography,ECC）是基于椭圆曲线数学的一种公钥密码算法，其安全性依赖于椭圆曲线离散对数问题的困难性。下面这3篇文章详细讲述了椭圆曲线密码算法的数学原理，不过是英文版的，但是讲述的非常详细，需要掌握的相关数学概念也讲述的很清楚。 http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/ http://andrea.corbellini.name/2015/05/23/elli..." }, { "title": "安装指定版本erlang与rabbitmq", "url": "/superLish.github.io/posts/%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACerlang%E4%B8%8Erabbitmq/", "categories": "CS, Backend", "tags": "rabbitmq", "date": "2017-09-29 08:55:00 +0800", "snippet": "安装部署Rabbitmq的时候要注意erlang与rabbitmq的版本问题，可参考RabbitMQ Erlang Version Requirements选择对应的版本进行安装部署。一、安装Erlang Adding repository entry```shellwget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.debsudo dpkg -i erlang-solutions_1.0_all.deb2. Installing Erlang```shellsudo apt-get updatesud..." }, { "title": "Linux内核oomkiller机制", "url": "/superLish.github.io/posts/Linux%E5%86%85%E6%A0%B8OOMkiller%E6%9C%BA%E5%88%B6/", "categories": "CS, Linux", "tags": "linux", "date": "2017-09-29 08:55:00 +0800", "snippet": "程序运行了一段时间，有个进程挂掉了，正常情况下进程不会主动挂掉，简单分析后认为可能是运行时某段时间内存占用过大，系统内存不足导致触发了Linux操作系统OOM killer机制，将运行中的进程杀掉了。一、Linux内核OOM killer机制Linux 内核有个机制叫OOM killer(Out Of Memory killer)，该机制会监控那些占用内存过大，尤其是瞬间占用内存很快的进程，然后防止内存耗尽而自动把该进程杀掉。内核检测到系统内存不足、挑选并杀掉某个进程的过程可以参考内核源代码linux/mm/oom_kill.c，当系统内存不足的时候，out_of_memory()被触发..." }, { "title": "以太坊学习笔记", "url": "/superLish.github.io/posts/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/", "categories": "CS, Blackchain", "tags": "Blockchain, Ethereum", "date": "2017-09-15 08:55:00 +0800", "snippet": "区块链就是一个具有共享状态的密码性安全交易的单机。以太坊作为比特币后非常有影响力的公有链，其本质就是一个基于交易的状态机。与其他分布式系统不同的是，它的目的就是要所有的节点拥有相同的状态。一、以太坊主要特点以太坊（Ethereum）目标是打造成一个运行智能合约的去中心化平台，平台上的应用按程序设定运行，不存在停机、审查、欺诈、第三方人为干预的可能。为了打造这个平台，以太坊提供了一条公开的区块链，并制定了面向智能合约的一套编程语言Solidity。智能合约开发者可以在其上使用官方提供的工具来开发支持以太坊区块链协议的应用。以太坊的特点主要包括： 单独为智能合约指定编程语言Solidity..." }, { "title": "日志库的设计思路", "url": "/superLish.github.io/posts/%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/", "categories": "CS, Backend", "tags": "log", "date": "2017-09-09 08:55:00 +0800", "snippet": "一、基本思路日志库的设计，抓住最核心的一条，就是日志从产生到到达最终目的地期间的处理流程。一般而言，为了设计一个灵活可扩展，可配置的日志库，可将日志库抽象为4个部分：记录器、过滤器、格式化器、输出器四部分。 组成 描述 记录器 负责产生日志记录的原始信息，比如（原始信息，日志等级，时间，记录的位置）等信息 过滤器 负责按指定的过滤条件过滤掉我们不需要的日志（比如按日志等级过滤） 格式化器 负责对原始日志信息按照我们想要的格式去格式化 ..." }, { "title": "Rust更换Crates源", "url": "/superLish.github.io/posts/Rust%E6%9B%B4%E6%8D%A2Crates%E6%BA%90/", "categories": "CS, Rust", "tags": "Rust", "date": "2017-09-08 20:55:00 +0800", "snippet": "Rust编译时遇到如下问题：Downloading futures v0.1.19warning: spurious network error (2 tries remaining): [28] Timeout was reached (Operation timed out after 30857 milliseconds with 0 out of 0 bytes received)error: unable to get packages from source Caused by: [35] SSL ..." }, { "title": "TCP保活机制", "url": "/superLish.github.io/posts/TCP%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6/", "categories": "CS, Network", "tags": "TCP/IP", "date": "2017-08-06 13:25:00 +0800", "snippet": "在需要长连接的网络通信程序中，经常需要心跳检测机制，来实现检测对方是否在线或者维持网络连接的需要。这一机制是在应用层实现的，对应的，在TCP协议中，也有类似的机制，就是TCP保活机制。一、为什么需要保活机制？设想这种情况，TCP连接建立后，在一段时间范围内双发没有互相发送任何数据。思考以下两个问题： 怎么判断对方是否还在线。这是因为，TCP对于非正常断开的连接系统并不能侦测到（比如网线断掉）。 长时间没有任何数据发送，连接可能会被中断。这是因为，网络连接中间可能会经过路由器、防火墙等设备，而这些有可能会对长时间没有活动的连接断掉。基于上面两点考虑，需要保活机制。二、TCP保活机制的实..." }, { "title": "二叉查找树", "url": "/superLish.github.io/posts/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2017-07-24 08:55:00 +0800", "snippet": "一、树的相关概念 空树：是高度为0的合法树； 单一节点：是高度为1的树（是节点既是根也是叶子的唯一情况）； 极端情况下，树退化为链表；（比如二叉查找树中，数据正好是已经排好序的，此时数据元素全部位于左子树或右子树，相当于链表结构） 二叉树：节点可以包含两个子节点（也可能为空）的树，每一个子节点都区分为左子节点或右子节点。 完全二叉树：所有的非终端节点都有两个子节点，所有的叶节点都位于同一层次； 对于非空二叉树，若其所有的非终端节点刚好有两个非空子节点，则叶节点的数目m大于非终端节点的数目k，并且m=k+1； 二叉查找树（有序二叉树）：对于树中的每个节点n，其左子树（根节点为..." }, { "title": "ARP协议", "url": "/superLish.github.io/posts/ARP%E5%8D%8F%E8%AE%AE/", "categories": "CS, Network", "tags": "TCP/IP", "date": "2017-06-06 13:25:00 +0800", "snippet": "ARP地址解析协议（IP地址—&amp;gt;MAC地址）地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机与主机之间的通信在物理上实质是网卡与网卡之间的通信，而网卡只认识MAC地址，所以要想实现主机与主机之间的通信，需要知道对方IP地址所对应的MAC地址，完成这一过程的协议就是ARP协议。在具体的网络传输过程中，使用地址解析协议，可根据网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）信息，以保证通信的顺利进行。ARP工作原理每台主机或路由器都有一个ARP缓存表，用来保存IP地址与M..." }, { "title": "Epoll边缘触发与水平触发", "url": "/superLish.github.io/posts/epoll%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91%E4%B8%8E%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91/", "categories": "CS, Linux", "tags": "linux", "date": "2017-06-05 08:55:00 +0800", "snippet": "在网络编程中，会涉及到水平触发与边缘触发的概念，工程中以边缘触发较为常见，本文讲述了边缘触发与水平触发的概念，并给出代码示例，通过代码可以很清楚的看到它们之间的区别。水平触发与边缘触发水平触发(level-trggered) 只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知， 当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知边缘触发(edge-triggered) 当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知， 当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知两者..." }, { "title": "boost库之noncopyable", "url": "/superLish.github.io/posts/boost%E5%BA%93noncopyable/", "categories": "CS, C/C++", "tags": "boost", "date": "2017-03-12 08:55:00 +0800", "snippet": "noncopyablenoncopyable允许程序轻松地实现一个禁止拷贝的类，noncopyable位于名字空间boost，为了使用noncopyable组件，需要包含头文件#include&amp;lt;boost/noncopyable.hpp&amp;gt;实现原理在C++中定义一个类时，如果不明确定义拷贝构造函数和拷贝赋值操作符，编译器会自动生成这两个函数。当我们希望禁止拷贝类的实例时，就不能用默认生成的这两个函数。这是一个很经典的C++惯用法，原理很好理解，只需要私有化拷贝构造函数和拷贝赋值操作符即可。class do_not_copy{private: do_not_cop..." }, { "title": "STL堆相关实现学习笔记", "url": "/superLish.github.io/posts/STL%E5%A0%86%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/", "categories": "CS, C/C++", "tags": "STL", "date": "2016-11-12 08:55:00 +0800", "snippet": "堆堆是十分重要的数据结构，我们常用的优先队列就是基于堆实现的数据结构，堆排序也是基于堆实现的，所以，我们要理解堆的实现，之前自己根据堆的原理自己实现了堆，现在来分析一下STL中堆的实现代码，STL的堆实现相比自己实现的代码肯定要多很多，但原理是一样的，我们下面看一下。堆的实现STL中提供了堆的一系列代码供人使用。我们分析一下。我们知道堆的存储形式是利用数组实现的，那给定一个数组序列，怎么判断它是不是堆呢？下面给出了判断是否是堆的实现代码，其原理十分简单，就是看是否满足堆性质，父节点大于等于子节点（最大堆）。当然这里is_heap还有其他重载形式，这里不再列出。 /** * @br..." }, { "title": "STL关联容器学习笔记", "url": "/superLish.github.io/posts/STL%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/", "categories": "CS, C/C++", "tags": "STL", "date": "2016-10-11 08:55:00 +0800", "snippet": "这里简单学习一下STL关联容器，主要是map、multimap、set、multiset以及unordered_map。前四个底层实现都是利用红黑树实现的，查找算法时间复杂度为O(log(n))，而unordered_map从名字上就知道是无序容器，其实现原理类似哈希表，查找算法时间复杂度O(1)。set、multiset、map、multimapset容器是一个存储有序唯一元素的数据结构。不允许有重复元素。其底层实现为红黑树。multiset原理与set相同，不同的是允许有重复元素存在。map映射是可以用任何类型的数据作为索引的表，不允许有重复元素，其实现原理与set类似，底层都是红黑..." }, { "title": "STL常用序列容器学习笔记", "url": "/superLish.github.io/posts/STL%E5%B8%B8%E7%94%A8%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/", "categories": "CS, C/C++", "tags": "STL", "date": "2016-09-12 08:55:00 +0800", "snippet": "这里简要的记述一下STL常用容器的实现原理，要点等内容。vectorvector是比较常用的stl容器，用法与数组是非类似，其内部实现是连续空间分配，与数组的不同之处在于可弹性增加空间，而array是静态空间，分配后不能动态扩展。vecotr的实现较为简单，主要的关键点在于当空间不足时，会新分配当前空间2倍的空间，将旧空间数据拷贝到新空间，然后删除旧空间。struct _Vector_impl: public _Tp_alloc_type { pointer _M_start; // 元素头 pointer _M_finish; // 元素尾 pointer _M..." }, { "title": "堆排序", "url": "/superLish.github.io/posts/%E5%A0%86%E6%8E%92%E5%BA%8F/", "categories": "CS, 数据结构与算法", "tags": "算法", "date": "2016-08-24 08:55:00 +0800", "snippet": "选择排序选择排序的基本思路是：每次都从原序列中顺序查找出最小的元素，放入新的序列的下一个位置（在具体实现中，一般是还是放在原序列中，采用依次交换位置的方法）。这种最简单实现的选择排序时间复杂度为O(n^2)。有没有效率更高的基于选择的排序算法呢？堆排序就是一种，与选择排序一样，堆排序是每次从原序列中取出最大（或最小）的元素，不同的是堆排序使用了堆这一数据结构，每次取出最大（最小）元素仅需O(log(n))，效率有所提高。堆排序排序方法非常多，这里的堆排序很好理解，就是指利用堆这种数据结构所设计的一种排序算法。具体排序思路如下：假定是升序排序，利用堆的性质，先由待排序数组构造最大堆，满足堆..." }, { "title": "TCP重置报文段及RST常见场景分析", "url": "/superLish.github.io/posts/TCP%E9%87%8D%E7%BD%AE%E6%8A%A5%E6%96%87%E6%AE%B5%E5%8F%8ARST%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/", "categories": "CS, Network", "tags": "TCP/IP", "date": "2016-08-06 13:25:00 +0800", "snippet": "RST表示连接重置，用于关闭那些已经没有必要继续存在的连接。产生RST的三个条件是： 目的地为某端口的SYN到达，然而在该端口上并没有正在监听的服务器； TCP想取消一个已有连接； TCP接收到一个根本不存在的连接上的分节。下面的几种场景，都会产生RST，以此来说明重置报文段的用途。一、针对不存在端口的连接请求客户端向服务端某端口发起连接请求SYN，但是目的服务端主机不存在该端口，此时向客户端回应RST，中断连接请求。下面通过程序和抓包进行分析。程序源码如下：use std::io::prelude::*;use std::net::TcpStream;use std::threa..." }, { "title": "TCP三次握手与四次分手", "url": "/superLish.github.io/posts/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B/", "categories": "CS, Network", "tags": "TCP/IP", "date": "2016-08-06 13:25:00 +0800", "snippet": "TCP首部TCP工作在传输层，提供应用程序到应用程序之间的可靠传输。学习TCP协议，首先从TCP协议头部开始： 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Source Port | ..." }, { "title": "排序", "url": "/superLish.github.io/posts/%E6%8E%92%E5%BA%8F/", "categories": "CS, 数据结构与算法", "tags": "算法", "date": "2016-07-24 08:55:00 +0800", "snippet": "排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。这里介绍的几种排序算法都是内部排序。冒泡排序法在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。时间复杂度O(n^2)。// 冒泡排序法template&amp;lt;class T&amp;gt;void bubble_sort(T* a, const int n) { T tmp; ..." }, { "title": "Dr.Memory内存检测工具", "url": "/superLish.github.io/posts/Dr.Memory%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/", "categories": "CS, Tools", "tags": "", "date": "2016-07-21 13:25:00 +0800", "snippet": "Dr. Memory 是一个开源免费的内存检测工具，它能够及时发现内存相关的编程错误，比如未初始化访问、内存非法访问以及内存泄露等。与 Valgrind 类似，可以直接检查已经编译好的可执行文件。用户不用改写被检查程序的源代码，也无须重新链接第三方库文件，使用起来非常方便。安装在Linux下安装参考Installing on Linux.使用示例示例1：#include &amp;lt;stdio.h&amp;gt;int main(){ // 对空指针指向的内存区域写，会发生段错误 int *null_ptr = NULL; *null_ptr = 10; return 0;}编译程序..." }, { "title": "网络错误:Destination_unreachable:Host_administratively_prohibited", "url": "/superLish.github.io/posts/%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF-Destination_unreachable-Host_administratively_prohibited/", "categories": "CS, Network", "tags": "", "date": "2016-05-06 13:25:00 +0800", "snippet": "问题描述：当其他主机向本地虚拟机中运行的服务程序发送数据时，服务端无法收到数据，wireshark抓包分析后，发现错误提示信息：Destination unreachable (Host administratively prohibited)。意思是：目的主机被强制禁止。基本可以断定是防火墙的问题，因为如果是目的主机不存在的话，报的错误是：Destination Host Unreachable，明显，目的主机存在但是包被目的主机主动过滤掉了，什么会将网络数据包过滤掉呢，最常想到的就是防火墙了。所以解决办法就是更改防火墙的配置或者直接关闭防火墙，因为我是与自己本地虚拟机进行通信，直接关..." }, { "title": "两个队列实现一个栈", "url": "/superLish.github.io/posts/%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2016-01-24 08:55:00 +0800", "snippet": "引申思考：如何用两个队列实现一个栈的功能？思路：举个例子：有D--&amp;gt;C--&amp;gt;B--&amp;gt;A数据依次入栈，输出顺序应该是A--&amp;gt;B--&amp;gt;C--&amp;gt;D。 先将D--&amp;gt;C--&amp;gt;B--&amp;gt;A入队列1，将C--&amp;gt;B--&amp;gt;A弹出到队列2，只留一个，弹出D； 再将队列2中所有数据入队列1，继续上面的步骤…… 大体就这个思路。代码如下：// 两个队列实现一个栈#include&amp;lt;queue&amp;gt;#include&amp;lt;..." }, { "title": "两个栈实现一个队列", "url": "/superLish.github.io/posts/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2016-01-14 08:55:00 +0800", "snippet": "问题：如何用两个栈实现一个对列的功能？思路：从栈A入队列，从栈B出队列。（队列的2个最重要的操作，入队列，出队列。） 入队列：从栈A入队列。 出队列：分两种情况 如果栈B不为空，直接弹出。 如果栈B为空，将栈A中的数据全部弹入栈B中，再从栈B弹出数据 代码实现如下：//2个栈实现一个队列#include&amp;lt;stack&amp;gt;#include&amp;lt;cassert&amp;gt;#include&amp;lt;iostream&amp;gt;using namespace std;template&amp;lt;clas..." }, { "title": "ICMP协议", "url": "/superLish.github.io/posts/ICMP%E5%8D%8F%E8%AE%AE/", "categories": "CS, Network", "tags": "TCP/IP", "date": "2015-08-06 13:25:00 +0800", "snippet": "ICMP协议在互联网传输过程中，IP数据报难免会出现差错，通常出现差错，处理方法就是丢弃，但是一般，出现差错后，会发送ICMP报文给主机，告诉它一些差错信息，以及对当前的网络状态进行一个探寻。可以说，ICMP的主要目的是用于在TCP/IP网络中发送出错和控制消息。ICMP报文封装如下：主要ICMP报文ICMP报文主要分三类，即差错报告报文、控制报文、请求/应答报文，如下图所示：目的不可达(Destination Unreachable Message) 0 1 2 3 ..." }, { "title": "算法题：无序数组中返回第k大的数.md", "url": "/superLish.github.io/posts/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E8%BF%94%E5%9B%9E%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0/", "categories": "CS, 数据结构与算法", "tags": "算法", "date": "2015-07-24 08:55:00 +0800", "snippet": "题目：输入一个序列，给出序列中第k大的数。解决思路： 对输入序列的前k个数构造最小堆，遍历后面k到n，如果有大于最小堆的最小值的，赋值过去，执行下移操作，遍历完成后，最小堆的根即为第k大的数。时间复杂度， 遍历一遍O(n) + 构造堆O(k) + 遍历时需要下移的k个操作O(log(k))代码如下：#include &amp;lt;iostream&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;// 最小堆// 这里堆中根节点元素在0位置处， iParent = (i-1)/2, iLeft = 2*i+1, iR..." }, { "title": "127.0.0.1与0.0.0.0及本机IP地址的区别", "url": "/superLish.github.io/posts/127.0.0.1%E4%B8%8E0.0.0.0%E5%8F%8A%E6%9C%AC%E6%9C%BAIP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB/", "categories": "CS, Network", "tags": "TCP/IP", "date": "2015-07-06 13:25:00 +0800", "snippet": "127.0.0.1，特殊的环回地址，大多数系统把此IP地址分配给换回接口分配给这个接口，并命名为localhost(主机名)，一般用来对运行在同一台主机上的程序通过TCP/IP进行通信。0.0.0.0，特殊的源地址，表示的是网络上的所有主机，一般在写服务端程序绑定监听地址时常用此地址。其实，127.x.x.x和0.0.0.0都是属于特殊情况的IP地址，可参考下表： 在这个图中， 0表示所有的比特位全为 0； - 1表示所有的比特位全为 1； n e t i d、 s u b n e t i d和h o s t i d分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划..." }, { "title": "Linux定时执行任务crontab", "url": "/superLish.github.io/posts/Linux%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1crontab/", "categories": "CS, Linux", "tags": "linux", "date": "2015-06-05 08:55:00 +0800", "snippet": "crontabcrontab可以定时执行任务，比如可以配置为每天几点执行什么任务，其实还可以配置为开机后执行一个任务。命令行输入crontab -e可进入编辑，每一行是一个定时任务，每个定时任务表示如下：# ┌───────────── minute (0 - 59)# │ ┌───────────── hour (0 - 23)# │ │ ┌───────────── day of the month (1 - 31)# │ │ │ ┌───────────── month (1 - 12)# │ │ │ │ ┌───────────── day of the week (0 - 6)..." }, { "title": "Linux进程间通信——信号", "url": "/superLish.github.io/posts/%E4%BF%A1%E5%8F%B7/", "categories": "CS, C/C++", "tags": "C", "date": "2015-05-20 08:55:00 +0800", "snippet": "一、认识信号信号（Signals）是Unix、类Unix以及其他POSIX兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。也可以简单理解为信号是某种形式上的软中断。二、信号来源一般情况下，信号的来源可分为以下三种： 硬件方式：除数为零、无效的存储访问等硬件异常产生信号。这些事件..." }, { "title": "Linux进程间通信——管道", "url": "/superLish.github.io/posts/%E7%AE%A1%E9%81%93/", "categories": "CS, C/C++", "tags": "C", "date": "2015-04-20 08:55:00 +0800", "snippet": "管道管道是一种最基本的进程间通信机制，由pipe函数创建：#include &amp;lt;unistd.h&amp;gt;int pipe(int filedes[2]);调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端。向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。管道代码示例子进程通过管道向父进程发送数据。限制在父子进程间通信。#include&amp;lt;stdlib.h&am..." }, { "title": "《C++PrimerPlus》读书笔记", "url": "/superLish.github.io/posts/C++PrimerPlus%E7%AC%94%E8%AE%B0/", "categories": "CS, C/C++", "tags": "", "date": "2015-03-12 08:55:00 +0800", "snippet": "函数模板函数模板是通用的函数描述，使用泛型来定义函数，其中的泛型可用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。代码见附录function_template.cpp显式具体化: 为特定类型提供具体化的模板定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及他们的重载版本。 显式具体化的原型和定义应以template&amp;lt;&amp;gt;开头，并通过名称来指出类型。 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。关键字decltype（C..." }, { "title": "多线程编程", "url": "/superLish.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/", "categories": "CS, C/C++", "tags": "C", "date": "2015-02-20 08:55:00 +0800", "snippet": "多线程编程可以说每个程序员的基本功，同时也是开发中的难点之一，下面讲述线程的创建及常用的几种线程同步的方式，最后对多线程编程进行了总结与思考并给出代码示例。一、创建线程多线程编程的第一步，创建线程。创建线程其实是增加了一个控制流程，使得同一进程中存在多个控制流程并发或者并行执行。线程创建函数，其他函数这里不再列出，可以参考pthread.h。#include&amp;lt;pthread.h&amp;gt;int pthread_create( pthread_t *restrict thread, /*线程id*/ const pthread_attr_t *restrict ..." }, { "title": "队列的实现", "url": "/superLish.github.io/posts/%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2015-02-14 08:55:00 +0800", "snippet": "队列队列的核心性质就是先入先出，类似于排队，在涉及到很多调度方面的问题的时候，比如线程池的任务调度等，每个工作线程从任务队列中取任务执行。还有一种队列经常会用到，那就是优先队列，优先队列的内容放到了堆那部分去总结，因为优先队列的实现底层就是堆。队列是一种先入先出的数据结构，其操作与栈类似。有如下操作： clear() —— 清空队列 empty() —— 判断队列是否为空 push() —— 入队列 pop() —— 出队列 front() —— 返回队列的第一个元素队列的链表实现代码如下：#include&amp;lt;cassert&amp;gt;#include&amp..." }, { "title": "栈的实现", "url": "/superLish.github.io/posts/%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/", "categories": "CS, 数据结构与算法", "tags": "数据结构", "date": "2015-01-24 08:55:00 +0800", "snippet": "栈的核心特点就是先入后出，在很多场景下都有应用，比如，在递归实现的各种算法中，很多就可以转化为栈实现，递归调用的时候，也是符合先入后出的性质的。深度优先算法的时候，很多就会用到栈的性质，广度优先一般会想到队列。栈是一种线性数据结构，存贮以及查找数据时只能访问栈的一端。即后进先出（LIFO，last in first out）结构。栈的主要操作如下： clear()——清空栈 isEmpty()——判断栈是否为空 push(el)——将元素el压进栈中 pop()——弹出栈顶部的元素 topEl()——获取栈顶部的元素，但不删除该元素最重要的就是push和pop。也是与其他数据结..." }, { "title": "性能分析工具之Valgrind简析", "url": "/superLish.github.io/posts/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E4%B9%8BValgrind%E7%AE%80%E6%9E%90/", "categories": "CS, Tools", "tags": "", "date": "2015-01-02 13:25:00 +0800", "snippet": "在对程序进行性能调优时，一般要首先进行性能测试，然后进行性能分析，分析后才进行性能调优，性能监控等。对性能分析，可使用系统或者性能分析工具进行性能分析。Linux性能分析工具可参考Linux性能分析工具.性能分析工具——Valgrind在使用Valgrind进行性能分析时，主要使用其中的Callgrind。Callgrind是一个分析工具，可以将程序运行中的函数之间的通话记录作为调用图记录。默认情况下，收集的数据由执行的指令数，它们与源行的关系，函数之间的调用者/被调用者关系以及这些调用的数量组成。可选地，高速缓存模拟和/或分支预测（类似于Cachegrind）可以产生关于应用的运行时行..." }, { "title": "Valgrind安装与使用", "url": "/superLish.github.io/posts/Valgrind%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/", "categories": "CS, Tools", "tags": "", "date": "2014-08-01 13:25:00 +0800", "snippet": "Valgrind是一款用于内存调试、内存泄漏检测以及性能分析的软件开发工具。Valgrind工具组提供了一套调试与分析错误的工具包，能够帮助你的程序工作的更加准确，更加快速。Valgrind的主要功能Valgrind工具包包含多个工具，如Memcheck、Cachegrind、Helgrind、Callgrind、Massif。下面分别介绍个工具的作用：MemcheckMemcheck工具主要检查下面的程序错误： 使用未初始化的内存 (Use of uninitialised memory) 使用已经释放了的内存 (Reading/writingmemory after it has..." }, { "title": "Git基础", "url": "/superLish.github.io/posts/Git%E5%9F%BA%E7%A1%80%E7%AF%87/", "categories": "CS, Tools", "tags": "git", "date": "2014-07-25 13:25:00 +0800", "snippet": "Git是开源的分布式版本控制系统，可以说是开发人员必备了，每个程序员都应该掌握。这里主要讲Git的安装与配置，工作区、暂存区、版本库的概念以及常用的一些命令。Linux下Git的安装与配置Ubuntu下可以运行以下命令安装：sudo apt install git ，安装成功后可查看Git版本：git --version。Git配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。这些环境变量，决定了Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig文件：系统中对所有用户都普遍适用的配置..." }, { "title": "C++虚函数的工作原理", "url": "/superLish.github.io/posts/C++%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/", "categories": "CS, C/C++", "tags": "", "date": "2014-06-11 08:55:00 +0800", "snippet": "静态绑定与动态绑定讨论静态绑定与动态绑定，首先需要理解的是绑定，何为绑定？函数调用与函数本身的关联，以及成员访问与变量内存地址间的关系，称为绑定。 理解了绑定后再理解静态与动态。 静态绑定：指在程序编译过程中，把函数调用与响应调用所需的代码结合的过程，称为静态绑定。发生在编译期。 动态绑定：指在执行期间判断所引用对象的实际类型，根据实际的类型调用其相应的方法。程序运行过程中，把函数调用与响应调用所需的代码相结合的过程称为动态绑定。发生于运行期。C++中动态绑定在C++中动态绑定是通过虚函数实现的，是多态实现的具体形式。而虚函数是通过虚函数表实现的。这个表中记录了虚函数的地址，解决继承..." }, { "title": "常用题目总结——字符串篇", "url": "/superLish.github.io/posts/%E5%B8%B8%E7%94%A8%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/", "categories": "CS, C/C++", "tags": "C", "date": "2014-04-20 08:55:00 +0800", "snippet": "1、如何统计一行中有多少个单词？问题：单词之间以空格隔开。代码如下：#include&amp;lt;stdio.h&amp;gt;#define BUFFSIZE 1024;int main() { char str[BUFFSIZE]; int i,count=0,word=0; char c; gets(str); for(int i=0;(c=str[i++])!=&#39;\\0&#39;;) { if(32==c) word=0; else if(0==word) { word=1; ++count; } } printf(&quot;count is %d..." }, { "title": "C++虚析构函数", "url": "/superLish.github.io/posts/C++%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/", "categories": "CS, C/C++", "tags": "", "date": "2014-04-20 08:55:00 +0800", "snippet": "C++虚析构函数主要关注两个问题，什么时候要用虚析构以及它是怎么工作的。下面回答这两个问题。问题1：什么时候要用虚析构函数?答案：通过基类的指针来删除派生类的对象时，基类的析构函数应该是虚的。这样做是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。原因：用对象指针来调用一个函数，有以下两种情况：如果是虚函数，会调用派生类中的版本; 如果是非虚函数，会调用指针所指类型的实现版本。 析构函数也会遵循以上两种情况。当对象出了作用域或是我们删除对象指针，析构函数就会被调用。当派生类对象出了作用域，派生类的析构函数会先调用，然后再调用它父类的析构函数，这样能保证分配给对象的..." }, { "title": "matlab笔记", "url": "/superLish.github.io/posts/matlab%E7%AC%94%E8%AE%B0/", "categories": "CS, Tools", "tags": "matlab", "date": "2014-03-25 13:25:00 +0800", "snippet": "初识matlab最初接触matlab是在大学时学习数学建模参加全国大学生数学建模竞赛时接触的，对于数学建模而言，Matlab是一款相当不错的建模辅助工具，因为 Matlab中有统计函数，线性分析函数，插值函数，非线性分析函数等等这些数模必备的函数，而且，Matlab强大的绘图功能可使很多数学演算过程变得可视化。这些对于分析问题及验证结果的正确性非常有帮助。matlab简介Matlab是MATrix LABoratory的缩写。Matlab开发的最初目的是为软件中的矩阵运算提供方便。Matlab是一种基于向量的高级程序语言，它将计算、可视化与程序设计集成在一个易用的环境中。换言之，Matl..." }, { "title": "C++拷贝构造函数被调用的时机", "url": "/superLish.github.io/posts/C++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84%E6%97%B6%E6%9C%BA/", "categories": "CS, C/C++", "tags": "", "date": "2014-03-12 08:55:00 +0800", "snippet": "拷贝构造函数调用的几种情况： 当用类的一个对象去初始化该类的另一个对象（或引用）时系统自动调用拷贝构造函数实现拷贝赋值。 若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。（这里有可能被编译器优化） 当函数的返回值是类对象时，系统自动调用拷贝构造函数。（注意会有编译器可能会进行优化，而观察不到拷贝的发生）#include&amp;lt;ctime&amp;gt;#include&amp;lt;cstdlib&amp;gt;#include&amp;lt;iterator&amp;gt;#include&amp;lt;algorithm&amp;gt;#in..." }, { "title": "C++中前置++与后置++运算符重载", "url": "/superLish.github.io/posts/C++%E4%B8%AD%E5%89%8D%E7%BD%AE++%E4%B8%8E%E5%90%8E%E7%BD%AE++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/", "categories": "CS, C/C++", "tags": "", "date": "2014-03-11 08:55:00 +0800", "snippet": "C++中前置++ 与后置++是不同的，具体不同，下面代码中有体现。在后置++里，人为添加一个参数（int），主要是为了区别前置++，这个参数不会被使用。这里的int是个哑元。一个函数的参数只有类型没有名字，则这个参数称之为哑元。class A{public: A&amp;amp; operator++() {//前置++，返回的是引用 data += 1; return *this; } const A operator++(int) { //后置++，返回的是值 A old(*this); ++(*this); //调用前置++ return old; }//从代码可以看出，..." }, { "title": "C++笔试题", "url": "/superLish.github.io/posts/C++%E7%AC%94%E8%AF%95%E9%A2%98/", "categories": "CS, C/C++", "tags": "", "date": "2014-03-10 08:55:00 +0800", "snippet": "1. 运行下面的C++代码，得到的结果是什么？#include&amp;lt;iostream&amp;gt;using namespace std;class A { public: A(int value): m_value(value) {} void Print1() { cout &amp;lt;&amp;lt; &quot;hello world&quot; &amp;lt;&amp;lt; endl; } void Print2() { cout &amp;lt;&amp;lt;..." }, { "title": "C++中空类和空结构体大小的问题", "url": "/superLish.github.io/posts/C++%E4%B8%AD%E7%A9%BA%E7%B1%BB%E5%92%8C%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98/", "categories": "CS, C/C++", "tags": "", "date": "2014-03-10 08:55:00 +0800", "snippet": "问题的提出有一个空类A，sizeof(A)=? 这个问题在笔试中经常遇到，答案是多少呢？class A {};代码求解#include&amp;lt;iostream&amp;gt;using namespace std;class A {};struct B {};int main() { cout &amp;lt;&amp;lt; sizeof(A) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; sizeof(B) &amp;lt;&amp;lt; endl; return 0;}运行结果：11可以看到C++中空类和空结构体的大小都..." } ]
