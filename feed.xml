<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://superlish.github.io/superLish.github.io/</id><title>ChirpyLi</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-04-07T11:04:46+08:00</updated> <author> <name>lisheng</name> <uri>https://superlish.github.io/superLish.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://superlish.github.io/superLish.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://superlish.github.io/superLish.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 lisheng </rights> <icon>/superLish.github.io/assets/img/favicons/favicon.ico</icon> <logo>/superLish.github.io/assets/img/favicons/favicon-96x96.png</logo> <entry><title>关于是否升级第三方库的思考</title><link href="https://superlish.github.io/superLish.github.io/posts/%E5%85%B3%E4%BA%8E%E6%98%AF%E5%90%A6%E5%8D%87%E7%BA%A7%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E6%80%9D%E8%80%83/" rel="alternate" type="text/html" title="关于是否升级第三方库的思考" /><published>2021-04-07T00:00:00+08:00</published> <updated>2021-04-07T00:00:00+08:00</updated> <id>https://superlish.github.io/superLish.github.io/posts/%E5%85%B3%E4%BA%8E%E6%98%AF%E5%90%A6%E5%8D%87%E7%BA%A7%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E6%80%9D%E8%80%83/</id> <content src="https://superlish.github.io/superLish.github.io/posts/%E5%85%B3%E4%BA%8E%E6%98%AF%E5%90%A6%E5%8D%87%E7%BA%A7%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E6%80%9D%E8%80%83/" /> <author> <name>lisheng</name> </author> <category term="CS" /> <category term="软件工程" /> <summary> 关于是否升级第三方库的思考 在开发中，我们经常需要很多依赖库或者使用很多第三方库，这里就有个问题了，我们什么时候需要升级依赖库或者是第三方库呢？之所以有这个问题，是因为，如果升级不当可能会对现有程序产生影响，造成目前的程序产生未知的问题。对未知影响最大是稳定性，系统稳定性在很多时候是非常非常重要的，对这个问题，有如下原则思考： 到了不得不升级的时候再升级，比如现有库功能无法满足要求，升级后的新版本可以满足功能要求。如果已有版本的功能已经满足现有要求，新版本增加的功能并不是现有需要的，则不升级。 新版本修复了已知Bug，这个没什么好说的，都有Bug了，不升版本问题解决不了。 新版本关键的性能指标有了很大的提升，而这个库又对现有程序的性能有较大的影响，即升级后对现有程序有很大的性能提升，则可以考虑升级。 所以，原则上能不升级版本就不升级，只有到不得不升级的时候再升级。 </summary> </entry> <entry><title>为什么要构建自己的博客</title><link href="https://superlish.github.io/superLish.github.io/posts/why-build-my-own-blog/" rel="alternate" type="text/html" title="为什么要构建自己的博客" /><published>2021-02-08T20:55:00+08:00</published> <updated>2021-02-17T16:41:16+08:00</updated> <id>https://superlish.github.io/superLish.github.io/posts/why-build-my-own-blog/</id> <content src="https://superlish.github.io/superLish.github.io/posts/why-build-my-own-blog/" /> <author> <name>lisheng</name> </author> <category term="Blogging" /> <category term="Diary" /> <summary> 为什么要构建自己的博客 之前一直在CSDN上写博客，也写了好久，但是CSDN的问题就是商业化气息太浓重了，个人比较喜欢简洁一些的风格。也在微信公众号上写了若干，但总觉得维护起来比较麻烦，尤其是想修改原文的时候。恰逢农历年因疫情原因不能回家，就有了一个构建自己的博客的想法，且趁这段时间将以前的博文梳理迁移过来,。 我对自己博客的想法就是，简洁，便于维护，方便归档查询。最终决定采用Github+Jekyll构建自己的博客，在theme中选取了自己喜欢的Chirpy。按照Chaipy-REAMDE文档的说明以及参考Working with GitHub Pages一步步构建出来。 Ready, Go! </summary> </entry> <entry><title>Rust异步之自己构造block_on</title><link href="https://superlish.github.io/superLish.github.io/posts/Rust%E5%BC%82%E6%AD%A5%E4%B9%8B%E8%87%AA%E5%B7%B1%E6%9E%84%E9%80%A0block_on/" rel="alternate" type="text/html" title="Rust异步之自己构造block_on" /><published>2021-02-05T20:55:00+08:00</published> <updated>2021-02-05T20:55:00+08:00</updated> <id>https://superlish.github.io/superLish.github.io/posts/Rust%E5%BC%82%E6%AD%A5%E4%B9%8B%E8%87%AA%E5%B7%B1%E6%9E%84%E9%80%A0block_on/</id> <content src="https://superlish.github.io/superLish.github.io/posts/Rust%E5%BC%82%E6%AD%A5%E4%B9%8B%E8%87%AA%E5%B7%B1%E6%9E%84%E9%80%A0block_on/" /> <author> <name>lisheng</name> </author> <category term="CS" /> <category term="Rust" /> <summary> 一个block_on代码示例 我们在进行异步编程时，经常会有下面形式的代码： use tokio::time::Duration; fn main() { let runtime = tokio::runtime::Builder::new_multi_thread() .enable_all() .build().unwrap(); runtime.block_on(hello()); } async fn hello() { tokio::time::sleep(Duration::from_secs(3)).await; println!("hello world."); } 我们看一下tokio中关于block_on的定义： /// Run a future to completion on the T... </summary> </entry> <entry><title>Rust中的Arc与Rc</title><link href="https://superlish.github.io/superLish.github.io/posts/Rust%E4%B8%AD%E7%9A%84Arc%E4%B8%8ERc/" rel="alternate" type="text/html" title="Rust中的Arc与Rc" /><published>2020-11-23T20:55:00+08:00</published> <updated>2020-11-23T20:55:00+08:00</updated> <id>https://superlish.github.io/superLish.github.io/posts/Rust%E4%B8%AD%E7%9A%84Arc%E4%B8%8ERc/</id> <content src="https://superlish.github.io/superLish.github.io/posts/Rust%E4%B8%AD%E7%9A%84Arc%E4%B8%8ERc/" /> <author> <name>lisheng</name> </author> <category term="CS" /> <category term="Rust" /> <summary> Rc 单线程引用计数。不是线程安全的，如果需要线程间引用计数可用Arc。注意他们之间的实现区别。关键源码实现如下，重点可关注Clone和Drop以及new的实现细节。 //! Single-threaded reference-counting pointers. 'Rc' stands for 'Reference Counted'. // This is repr(C) to future-proof against possible field-reordering, which // would interfere with otherwise safe [into|from]_raw() of transmutable inner types. #[repr(C)] struct RcBox&amp;lt;T: ?Sized&amp;gt; { strong: Cell&amp;lt;u... </summary> </entry> <entry><title>树堆</title><link href="https://superlish.github.io/superLish.github.io/posts/%E6%A0%91%E5%A0%86/" rel="alternate" type="text/html" title="树堆" /><published>2020-06-15T08:55:00+08:00</published> <updated>2020-06-15T08:55:00+08:00</updated> <id>https://superlish.github.io/superLish.github.io/posts/%E6%A0%91%E5%A0%86/</id> <content src="https://superlish.github.io/superLish.github.io/posts/%E6%A0%91%E5%A0%86/" /> <author> <name>lisheng</name> </author> <category term="CS" /> <category term="数据结构与算法" /> <summary> 树堆 树堆，是一种将二叉查找（搜索）树与堆两种数据结构结合在一起的一种数据结构，它首先是一颗二叉查找树同时满足一定的堆性质。我们知道二叉查找树与堆性质是有矛盾的，解决办法就是元素值以二叉查找树的性质分布，每个元素插入时都会随机生成一个优先级，优先级要满足堆性质中父节点大于等于子节点的性质，但不要求满足完全二叉树的堆性质。这样做的好处是：使二叉查找树保持一定的平衡性。 树堆的实现 树堆的实现，主要是堆怎么融到二叉查找树中，我们知道维护堆性质，需要经常交换父子节点的值，这里如果直接交换会破坏二叉查找树的性质，怎么办呢？用旋转的方法，交换父子节点的值不是目的，目的是维护堆父节点大于子节点的性质，用旋转的方法同样等做到这一点，同时还保证了二叉查找树的性质。 查找 查找的过程与二叉查找树的查找过程一样，此时忽略优先级。 插入 插入的思路如下：新元素先按其值插入到二叉查找树中，方法... </summary> </entry> </feed>
