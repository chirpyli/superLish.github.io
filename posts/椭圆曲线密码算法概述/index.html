<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="椭圆曲线密码算法概述" /><meta name="author" content="lisheng" /><meta property="og:locale" content="en_US" /><meta name="description" content="椭圆曲线密码算法" /><meta property="og:description" content="椭圆曲线密码算法" /><link rel="canonical" href="https://superlish.github.io/superLish.github.io/posts/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/" /><meta property="og:url" content="https://superlish.github.io/superLish.github.io/posts/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/" /><meta property="og:site_name" content="ChirpyLi" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2017-10-03T08:55:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="椭圆曲线密码算法概述" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@lisheng" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"椭圆曲线密码算法","url":"https://superlish.github.io/superLish.github.io/posts/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/","headline":"椭圆曲线密码算法概述","dateModified":"2021-02-17T16:41:16+08:00","@type":"BlogPosting","datePublished":"2017-10-03T08:55:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://superlish.github.io/superLish.github.io/posts/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"},"author":{"@type":"Person","name":"lisheng"},"@context":"https://schema.org"}</script><title>椭圆曲线密码算法概述 | ChirpyLi</title><link rel="shortcut icon" href="/superLish.github.io/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/superLish.github.io/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/superLish.github.io/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/superLish.github.io/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/superLish.github.io/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/superLish.github.io/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/superLish.github.io/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/superLish.github.io/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/superLish.github.io/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/superLish.github.io/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/superLish.github.io/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/superLish.github.io/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/superLish.github.io/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/superLish.github.io/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/superLish.github.io/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/superLish.github.io/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/superLish.github.io/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/superLish.github.io/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/superLish.github.io/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/superLish.github.io/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/superLish.github.io/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/superLish.github.io/assets/js/dist/post.min.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <script defer src="/superLish.github.io/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/superLish.github.io/" alt="avatar" class="mx-auto"> <img src="https://cdn.jsdelivr.net/gh/cotes2020/chirpy-images/commons/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/superLish.github.io/">ChirpyLi</a></div><div class="site-subtitle font-italic">love yourself</div></div><ul class="w-100"><li class="nav-item"> <a href="/superLish.github.io/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/superLish.github.io/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/superLish.github.io/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/superLish.github.io/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/superLish.github.io/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/superLish" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/superLish.github.io/"> Posts </a> </span> <span>椭圆曲线密码算法概述</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>椭圆曲线密码算法概述</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Oct 3, 2017, 8:55 AM +0800" > Oct 3, 2017 <i class="unloaded">2017-10-03T08:55:00+08:00</i> </span> by <span class="author"> lisheng </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 17, 2021, 4:41 PM +0800" > Feb 17 <i class="unloaded">2021-02-17T16:41:16+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3443 words">19 min</span></div></div><div class="post-content"><h2 id="椭圆曲线密码算法">椭圆曲线密码算法</h2><p>椭圆曲线密码算法（Elliptic Curve Cryptography,ECC）是基于椭圆曲线数学的一种公钥密码算法，其安全性依赖于椭圆曲线离散对数问题的困难性。</p><p>下面这3篇文章详细讲述了椭圆曲线密码算法的数学原理，不过是英文版的，但是讲述的非常详细，需要掌握的相关数学概念也讲述的很清楚。</p><blockquote><p>http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/ <br /> http://andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/ <br /> http://andrea.corbellini.name/2015/05/30/elliptic-curve-cryptography-ecdh-and-ecdsa/</p></blockquote><p>下面这2篇是上面文章的翻译：</p><blockquote><p>http://blog.csdn.net/mrpre/article/details/72850598 <br /> http://blog.csdn.net/mrpre/article/details/72850644</p></blockquote><h3 id="椭圆曲线密码算法优点">椭圆曲线密码算法优点</h3><ul><li>短的密钥长度，意味着小的带宽和存储要求。<li>所有的用户可以选择同一基域上的不同的椭圆曲线，可使所有的用户使用同样的操作完成域运算。</ul><h3 id="椭圆曲线定义">椭圆曲线定义</h3><p>设\(p\)是一个大于3的素数，在有限域\(F_p\)上的椭圆曲线\(y^2=x^3+ax+b\)由一个基于同余式\(y^2=x^3+ax+b \ mod \ p\)的解集\((x,y)\in F_p\times F_p\)和一个无穷远点的特定点\(O\)组成，这里\(a,b \in F_p\)是满足\(4a^3+27b^2 \neq 0 \ mod \ p\)的常数。</p><p>下图是显示了其中一种实际的椭圆曲线：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1391c25f0971?w=409&amp;h=410&amp;f=png&amp;s=8535" alt="这里写图片描述" /></p><p>对椭圆曲线上的点，我们可以定义一种形式的加法：如果椭圆曲线上的三个点位于同一直线上，那么它们的和为\(O\)（无穷远点）。</p><p>根据上面的定义导出椭圆曲线上的加法运算法则如下： 当\(P \neq Q\)时： <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1391c2335359?w=442&amp;h=492&amp;f=png&amp;s=33449" alt="这里写图片描述" /></p><p>当\(P=Q\)时： <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1391c24f03ca?w=431&amp;h=475&amp;f=png&amp;s=26762" alt="这里写图片描述" /></p><p>下面的动画解释了为什么是切线：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1391c2cdc083?w=300&amp;h=300&amp;f=gif&amp;s=257876" alt="这里写图片描述" /></p><p>随着两个点越来越接近，过这两点的直线最终变成了曲线的切线</p><p>上面用几何的形式解释了椭圆曲线上的加法法则，下面是数学表达式。设\(P_1=(x_1,y_1)\)与\(P_2=(x_2,y_2)\)为椭圆曲线上的两个点，加减法运算如下： <br /> 1） \(-O=O\) <br /> 2） \(-P_1=(x_1,-y_1)\) <br /> 3） \(O+P_1=P_1\) <br /> 4） 若\(P_2=-P_1\)，则\(P_1+P_2=O\) <br /> 5） 若\(P_2 \neq -P_1\)，则\(P_1+P_2=(x_3,y_3)\)，其中\(x_3=m^2-x_1-x_2\)，\(-y_3=m(x_3-x_1)+y_1\)，<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1391c2e01620?w=185&amp;h=56&amp;f=gif&amp;s=1233" alt="这里写图片描述" /></p><h2 id="椭圆曲线上点群的离散对数问题">椭圆曲线上点群的离散对数问题</h2><p>给定椭圆曲线上的点\(P\)和点\(Q\)，寻找数\(k\)，使得\(kP=Q\)，其中\(k\)称为\(Q\)的基于\(P\)的离散对数。</p><p>在等式\(kP=P+P+\dots +P=Q\)中，已知\(k\)和点\(P\)，求点\(Q\)比较容易，反之已知点\(Q\)和点\(P\)，求\(k\)却是相当苦难的，这个问题称为椭圆曲线上点群的离散对数问题。椭圆曲线密码体制正是利用这个困难问题设计的。在实际应用中，\(k\)作为私钥，而\(Q\)作为公钥。</p><h3 id="如何计算kpppdots-pq">如何计算\(kP=P+P+\dots +P=Q\)</h3><p>用这种形式表示时，计算\(kP\)似乎需要\(k\)次加法运算。如果\(k\)有\(n\)个二进制位，那么算法的时间复杂度将为\(O(2^n)\)，这真不是很好。存在一些更快的算法。其中一种是“加倍（double)与相加（add)”算法。计算的原理可以用一个例子来更好地解释。取\(n = 151\)。它的二进制表示形式为\(10010111_2\) 。这一二进制表示形式可以转换为一系列\(2\)的幂之和。</p><p>(取\(k\)的 每个二进制位上的数字，并用它乘以一个\(2\)的幂.) 用这种方法，我们可以将\(k\)这样写:</p><p>“加倍（double)与相加（add)”算法需要这样做: • 取\(P\). • 加倍，得到\(2P\). • \(2P\)与\(P\)相加(为了得到 \(2^1P + 2^0P\)). • 加倍 \(2P\)，得到\(2^2 P\). • 与前一结果相加 (得到 \(2^2P + 2^1P + 2^0P\)). • 加倍 \(2^2P\)，得到\(2^3P\). • 对\(2^3P\)不做任何操作. • 加倍\(2^3P\)，得到\(2^4P\). • 与前一结果相加 (得到 \(2^4P + 2^2P + 2^1P + 2^0P\)). • … 最后，我们可以计算\(151 • P\)，只需7次“加倍”运算和4次“相加”运算。</p><h3 id="secp256k1椭圆曲线">secp256k1椭圆曲线</h3><p>在比特币区块链实现中使用的椭圆曲线为secp256k1。所以这里需要学习一下。 secp256k1曲线形如\(y^2=x^3+ax+b\)，由六元组\(D=(p,a,b,G,n,h)\)定义，其中： \(p=FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1\) \(a = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\) \(b = 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000007\) The base point G in compressed form is（压缩形式表示的基点G定义）: \(G = 02 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798\) and in uncompressed form is（非压缩形式表示）: \(G = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8\) Finally the order n of G and the cofactor are（G的阶、协因子）:</p><p>G的阶：\(n = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141\) 协因子：\(h = 01\) secp256k1椭圆曲线形状如下： <br /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1391c2ff14f7?w=600&amp;h=600&amp;f=png&amp;s=16012" alt="这里写图片描述" /> This is a graph of secp256k1’s elliptic curve \(y^2 = x^3 + 7\) over the real numbers. Note that because secp256k1 is actually defined over the field \(Z_p\), its graph will in reality look like random scattered points, not anything like this. 详细参考：https://en.bitcoin.it/wiki/Secp256k1</p><blockquote><p>椭圆曲线参数 六元组解释： 我们的椭圆曲线算法是工作在循环子群上的。几个参数含义如下：<br /> （1）素数\(p\)，这个值定义了有限域的大小<br /> （2）椭圆曲线的系数\(a\)、\(b\) <br /> （3）基点\(G\)（子群的生成元） <br /> （4）子群的阶\(n\) <br /> （5）协因子\(h\) (\(h = N/n\))</p></blockquote><h2 id="补充数学概念">补充数学概念</h2><p>这里所用到的密码学其数学基础主要是《数论》、《代数》。如果想要弄清其原理，这两部分数学基础是需要研读的。</p><h3 id="同余式">同余式</h3><p>数学上，同余（congruence modulo，符号：≡）是数论中的一种等价关系。当两个整数除以同一个正整数，若得相同余数，则二整数同余。同余是抽象代数中的同余关系的原型。</p><p>两个整数\(a,b,\)若它们除以正整数\(m\)所得到的余数相等，则称\(a,b\)对于模\(m\)同余，记作\(a \equiv b\) \((mod \ m)\)。读作\(a\)与\(b\)关于模\(m\)同余。（例 \(26 \equiv 14 (mod \ 12)\)）。同余式的其他详细参考<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98">wiki</a></p><h3 id="密码学与有限循环群">密码学与有限循环群</h3><p>现代密码学算法和协议中，消息是作为有限空间中的数字或元素来处理的。加密和解密的各种操作必须在消息之间进行变换，以使变换服从有限消息空间内部的封闭性。然而，数的一般运算诸如加减乘除并不满足有限空间内部的封闭性。所以密码算法通常运行于具有某些保持封闭性的代数结构的空间中，这种代数结构就是有限循环群。在数学中，群是一种代数结构，由一个集合以及一个二元运算组成。群必须满足以下四个条件：封闭性，结合律，存在单位元和存在逆元。</p><blockquote><p>群(Group)的定义： 设\(G\)是一个非空集合，对于\(G\)中的任意两个元素\(a,b\)，乘法运算满足以下条件，那么\(G\)称为一个群： <br /> (1). 对于\(G\)中任意元素\(a,b,c\)，有\(a(bc)=(ab)c\). <br /> (2). 在\(G\)中存在一个元素\(e\)，它对\(G\)中任意元素\(a\)有\(ea=a\).（有单位元）<br /> (3). 对于\(G\)中任意元素\(a\)，都存在\(G\)中一个元素\(b\)使的\(ba=e\).（有逆）</p></blockquote><p>最常见的群之一是整数集\(Z\)以及加法操作。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1391f1a71fd1?w=267&amp;h=148&amp;f=png&amp;s=64791" alt="这里写图片描述" /></p><p>有限循环群在群的基础上满足两个额外条件：群元素个数有限以及交换律。循环群由单个元素（产生元）的叠加操作生成，最常见的有限循环群为模拟时钟。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1391f4aa9557?w=219&amp;h=394&amp;f=png&amp;s=94574" alt="这里写图片描述" /></p><h3 id="椭圆曲线群定义">椭圆曲线群定义</h3><p>在数学上，椭圆曲线群的元素为椭圆曲线上的点，群操作为”+”,”+”的定义为，给定曲线两点\(P\)，\(Q\)，\(P+Q\)等于\(P\)和\(Q\)两点的连线与曲线交点沿\(X\)轴的对称点，如果\(P=Q\)，则\(P+P\)等于\(P\)在曲线上的切线与曲线交点沿\(X\)轴的对称点。该群的单位元为无穷远零点记作\(O=(0,0)\)，有\(P+O=P\)，点\(P\)的逆元为其沿\(X\)轴的对称点，记作\(-P\)。</p><h3 id="椭圆曲线有限循环群">椭圆曲线有限循环群</h3><p>前面介绍的椭圆曲线都是基于有理数的，但是计算机运算浮点数(小数)的速度较慢，更重要的是四舍五入浮点数会产生误差，导致多次加密解密操作后原始消息不能被还原。故考虑到加密算法的可实现性，密码学上使用基于整数的模加运算产生椭圆曲线有限循环群。 基于整数的模加运算的特点：</p><ul><li>运算速度快<li>精确的运算结果<li>产生有限循环</ul><p>下面举例说明，如何产生ECC有限循环群： 例如考虑\(y^2=x^3-7x+10 (mod \ 19)\)的集合，该集合中所有的元素如下图所示。模运算把发散的椭圆曲线映射到19*19的正方形空间中，并且保持了原有曲线的上下对称特性。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1391f4c65a33?w=383&amp;h=366&amp;f=png&amp;s=43459" alt="这里写图片描述" /></p><p>下图展示了\(y^2=x^3-7x+10(mod \ 19)\)集合中的元素和椭圆曲线的关系。 点\(Q’\)映射到点\(Q\)，点\(P\)的对称点也由点\(-P’\)映射到点\(-P\)。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc139206982a12?w=215&amp;h=457&amp;f=png&amp;s=45128" alt="这里写图片描述" /></p><p>如果取一个更大的质数\(p\)进行模运算，集合中的元素点也会相应地增多。下图展示了利用同一个曲线方程进行不同模运算的结果。在实际的椭圆曲线加密算法中，使用长度为192-256位的质数\(p\)进行模运算。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc13922f3d908e?w=608&amp;h=608&amp;f=png&amp;s=83656" alt="这里写图片描述" /></p><p>现在我们基于\(y^2=x^3-7x+10(mod \ 19)\)，利用产生元\(P=(2,2)\)来生成ECC有限循环群。如下图所示。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc13922f07f92e?w=166&amp;h=377&amp;f=png&amp;s=82908" alt="这里写图片描述" /></p><p>\(G=\{ nP\) \(\vert\) \(P=(2,2)\}\)完整的集合为\(\{p=(2,2),2P=(13,8),3P=(1,2),4P=(16,17),5P=(10,3),6P=(18,15),7P=(3,15),8P=(12,1),9P=(9,12),10P=(5,10),11P=(17,15),12P=(7,0),13P=(17,4),14P=(5,9),15P=(9,7),16P=(12,18),17P=(3,4),18P=(18,4),19P=(10,16),20P=(16,2),21P=(1,17),22P=(13,11),23P=(2,17),24P=O=(0,0)\}\)。</p><p>如下图所示，随着\(n\)的连续增加，元素点的分布没有任何特征，这正是密码学需要的特性。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc1392337cea38?w=314&amp;h=301&amp;f=png&amp;s=26948" alt="这里写图片描述" /></p><blockquote><p>可参考：http://mp.weixin.qq.com/s/jOcVk7olBDgBgoy56m5cxQ</p></blockquote><h4 id="椭圆曲线的阶">椭圆曲线的阶</h4><p>椭圆曲线定义在有限域上，这也意味着，椭圆曲线上的点也是有限的。所以引出了一个问题：一个椭圆曲线到底有多少个点？定义“椭圆曲线上点的个数”为 椭圆曲线的 阶 (order)。至于怎么计算阶参考这篇文章吧： https://en.wikipedia.org/wiki/Schoof%27s_algorithm</p><h4 id="椭圆曲线的数乘和循环子群">椭圆曲线的数乘和循环子群</h4><p>在实数域，数乘（标量乘法）被定义如下：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc139234098954?w=233&amp;h=63&amp;f=png&amp;s=1946" alt="这里写图片描述" /></p><p>如何计算及算法复杂度，上面有讲过，这里讲述它的一个性质。举例说明： 椭圆曲线\(y^2 \equiv x^3+2x+3 \ (mod \ 97)\)，点\(P=(3,6)\)。现在计算\(P\)的数乘。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc139237d0f735?w=721&amp;h=744&amp;f=png&amp;s=60484" alt="这里写图片描述" /></p><p>上图可以化为下图的表示形式：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-gold-cdn.xitu.io/2019/7/5/16bc13925d331d16?w=247&amp;h=171&amp;f=png&amp;s=6166" alt="这里写图片描述" /></p><p>结果显示点\(P\)的倍数的结果只有出现5个点，其他的点从未出现；其次他们是周期出现的。 显然，上面的5个点的集合，运算是封闭的。 当然，不仅仅\(P\)有这样的性质，其他点也有类似的性质。 即，\(P\)的加法构成了一个群\(S\)，由于\(S\)属于\(G\)，故\(S\)是\(G\)的子群。 循环子群是ECC的基础。</p><h4 id="子群的阶">子群的阶</h4><ol><li>首先，我们已经定义了阶就是群中点的个数。在子群中也是这样的，但是我们可以换一种表达方式：子群的阶是最小能够使得\(nP=0\)的\(n\)。<li>子群的阶和群的阶是有关系的。拉格朗日定理说明了，子群的阶是群的阶的因子。即如果\(N\)是群的阶，则其子群的阶\(n\)，则\(n\)是\(N\)的因子（\(n\) is a diviser of \(N\)）。</ol><p>找到子群的阶的方法（根据上面讲述的定义和性质就能得出下面的方法）：<br /> （1）计算群的阶\(N\)<br /> （2）找出所有\(N\)的因子 <br /> （3）每个\(N\)的因子\(n\)，然后乘以\(P\) <br /> （4）在3中，找出最小的\(n\)，使得满足\(nP = 0\)。则\(n\)是子群的阶。</p><h4 id="如何找一个基点">如何找一个基点</h4><p>在ECC算法种，我们希望找到一个阶数较大的子群。 通常我们会选择一个椭圆曲线，然后计算它的阶\(N\)，选择一个较大的因子\(n\)，然后找一个合适的基点。也就是说，我们不是首先找一个基点，然后计算它的阶，而是相反，我们先找到一个合适的阶，然后找以这个数为阶的子群的生成元。</p><p>首先，拉格朗日揭示，\(h = N/n\)是一个整数（当然，\(n\)是\(N\)的因子），\(h\)有一个自己的名字：cofactor of the subgroup（协因子）。</p><p>其次，每个椭圆曲线上的点\(P\)，\(NP = 0\)，因为\(N\)是\(P\)的阶\(n\)的倍数。 我们可以写成这样 \(n(hP) = 0\)。 假设\(n\)是一个素数，我们令\(G= hP\)，则\(G\)就是子群的生成元。 \(n\)必须是素数，若非如此，则\(nP = 0\)不一定表示\(n\)是\(P\)的阶，因为\(P\)的阶可能是\(n\)的一个因子。 总结如下：</p><ol><li>计算椭圆曲线的阶\(N\)。<li>选择一个数\(n\)当成子群的阶。\(n\)应该是\(N\)的素因数<li>计算\(h = N/n\)<li>随机选择一个点\(P\)<li>计算\(G = hP\)<li>如果\(G\)是\(0\)，到第4步。否则，我们找到了这个基点。</ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/superLish.github.io/categories/cs/'>CS</a>, <a href='/superLish.github.io/categories/crypto/'>Crypto</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/superLish.github.io/tags/crypto/" class="post-tag no-text-decoration" >crypto</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/superLish.github.io/posts/%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E8%BF%94%E5%9B%9E%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0/">算法题：无序数组中返回第k大的数.md</a><li><a href="/superLish.github.io/posts/%E6%8E%92%E5%BA%8F/">排序</a><li><a href="/superLish.github.io/posts/%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF-Destination_unreachable-Host_administratively_prohibited/">网络错误:Destination_unreachable:Host_administratively_prohibited</a><li><a href="/superLish.github.io/posts/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E5%88%86%E6%89%8B/">TCP三次握手与四次分手</a><li><a href="/superLish.github.io/posts/TCP%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%80%BB%E8%BE%91/">谈谈TCP</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/superLish.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="post-tag" href="/superLish.github.io/tags/rust/">Rust</a> <a class="post-tag" href="/superLish.github.io/tags/crypto/">crypto</a> <a class="post-tag" href="/superLish.github.io/tags/blockchain/">Blockchain</a> <a class="post-tag" href="/superLish.github.io/tags/tcp-ip/">TCP/IP</a> <a class="post-tag" href="/superLish.github.io/tags/elk/">ELK</a> <a class="post-tag" href="/superLish.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a> <a class="post-tag" href="/superLish.github.io/tags/linux/">linux</a> <a class="post-tag" href="/superLish.github.io/tags/c/">C</a> <a class="post-tag" href="/superLish.github.io/tags/ethereum/">Ethereum</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/superLish.github.io/posts/AES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"><div class="card-body"> <span class="timeago small" > Apr 9, 2018 <i class="unloaded">2018-04-09T08:55:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AES加密算法原理</h3><div class="text-muted small"><p> 密码学博大精深，这里所说的AES加密算法原理可以理解为AES工作流程，至于为什么这么设计，这么设计为什么是安全的，有待今后的学习与思考。 分组密码设计的两个原则 分组密码设计的两个原则：混淆(confusion)和扩散(diffusion)，其目的是抗击敌手对密码系统的统计分析。 混淆是使密文的统计特性与密钥的取值之间的关系 尽可能复杂化，以使密钥和明文以及密文之间的依赖性对密码...</p></div></div></a></div><div class="card"> <a href="/superLish.github.io/posts/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%8F%8AAES%E7%AE%97%E6%B3%95%E5%88%9D%E8%AF%86/"><div class="card-body"> <span class="timeago small" > May 19, 2018 <i class="unloaded">2018-05-19T08:55:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>分组密码及AES算法初识</h3><div class="text-muted small"><p> 对称密码算法 常用对称密码算法AES、Blowfish、DES、RC5等，DES目前认为已不安全，当前使用最多的是AES加密算法，因其应用的广泛，目前主流CPU已经实现了AES-NI（全称是：Advanced Encryption Standard New Instructions），这是针对AES加密算法的硬件加解密CPU指令集。通过硬件加速，能实现吞吐量成倍的提升。所以这里重点学习AES...</p></div></div></a></div><div class="card"> <a href="/superLish.github.io/posts/Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2/"><div class="card-body"> <span class="timeago small" > Jun 11, 2018 <i class="unloaded">2018-06-11T08:55:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Diffie-Hellman密钥交换</h3><div class="text-muted small"><p> DH密钥交换是一种安全协议，它可以让双方在不安全的信道上创建一个密钥。双方互相发送的数据就算被第三方知晓，也无法知道加密信息的密钥。 其解决问题的主要思想可以用下图来解释： Alice和Bob想要协商出一个只有它们两人知道的颜色，不能让第三方知道，怎么办呢？解决办法如下： 先从它们共同拥有的颜色（图中为黄色）开始，这个黄色是大家都知道的，第三方知道也没有关系。 Alice选...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/superLish.github.io/posts/%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACerlang%E4%B8%8Erabbitmq/" class="btn btn-outline-primary" prompt="Older"><p>安装指定版本erlang与rabbitmq</p></a> <a href="/superLish.github.io/posts/RefCell%E5%92%8C%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7/" class="btn btn-outline-primary" prompt="Newer"><p>RefCell和内部可变性</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/superLish">lisheng</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/superLish.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a class="post-tag" href="/superLish.github.io/tags/rust/">Rust</a> <a class="post-tag" href="/superLish.github.io/tags/crypto/">crypto</a> <a class="post-tag" href="/superLish.github.io/tags/blockchain/">Blockchain</a> <a class="post-tag" href="/superLish.github.io/tags/tcp-ip/">TCP/IP</a> <a class="post-tag" href="/superLish.github.io/tags/elk/">ELK</a> <a class="post-tag" href="/superLish.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a> <a class="post-tag" href="/superLish.github.io/tags/linux/">linux</a> <a class="post-tag" href="/superLish.github.io/tags/c/">C</a> <a class="post-tag" href="/superLish.github.io/tags/ethereum/">Ethereum</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/superLish.github.io/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://superLish.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
